# -*- coding: utf-8 -*-
"""
/***************************************************************************
 OpenTripPlannerPlugin
                                 A QGIS plugin
 This plugin makes OpenTripPlanner functionalities accessible in QGIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-10-21
        git sha              : $Format:%H$
        copyright            : (C) 2019 - Today by Mario KÃ¶nigbauer
        email                : mkoenigb@gmx.de
        repository           : https://github.com/mkoenigb/OpenTripPlannerPlugin
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QObject, QThread, pyqtSignal
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog
from PyQt5.QtNetwork import  QNetworkAccessManager, QNetworkRequest
from PyQt5.QtCore import *
from qgis.core import *
from qgis.utils import *


# Initialize Qt resources from file resources.py
from .resources import *
from .otp_plugin_general_functions import *
# Import the code for the dialog
from .otp_plugin_dialog import OpenTripPlannerPluginDialog
from osgeo import ogr
from datetime import *
import processing
import os
import urllib
import zipfile
import json

MESSAGE_CATEGORY = 'OpenTripPlanner PlugIn'

class OpenTripPlannerPluginMaxIsochronesWorker(QThread):
    maxisochrones_finished = pyqtSignal(object, int, str, str)
    maxisochrones_progress = pyqtSignal(int)

    def __init__(self, dialog, iface, otpgf, resultlayer):
        super(QThread, self).__init__()
        self.dlg = dialog
        self.gf = otpgf
        self.iface = iface
        self.stopmaxisochronesworker = False
        self.maxisochrones_memorylayer_vl = resultlayer
        self.maxisochrones_state = 0
        self.gf.read_general_variables()
        #self.gf.read_isochrone_variables()
    
    def stop(self):
        self.stopmaxisochronesworker = True

        
    def run(self):        
        # clear and initialize vars and stuff
        self.maxisochrones_state = 1
        maxisochrone_url = None
        maxisochrone_error = None
        maxisochrone_errors = []
        tmp_maxisochrones_error = None
        tmp_maxisochrones_errors = []
        unique_errors = []
        r = None
        inputlayer_outfeat = None
        debug_info = None
        maxisochrone_uid_counter = 0
        maxisochrone_id_counter = 0
        maxisochrones_memorylayer_vl = self.maxisochrones_memorylayer_vl
        
        QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info)
        QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info)
        QgsMessageLog.logMessage("##### Max-Isochrones job starting @ " + str(datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")) + " #####",MESSAGE_CATEGORY,Qgis.Info)
        QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info)
        maxisochrones_starttime = datetime.now()
        
        
        # Setting up Override Button context
        ctx = QgsExpressionContext(QgsExpressionContextUtils.globalProjectLayerScopes(self.gf.maxisochrones_selectedlayer)) #This context will be able to evaluate global, project, and layer variables
        
        # Preparing Features
        inputlayer_features = self.gf.maxisochrones_selectedlayer.getFeatures()
        
        # Create the Output-Vectorlayer
        with edit(maxisochrones_memorylayer_vl):
            maxisochrones_memorylayer_pr = maxisochrones_memorylayer_vl.dataProvider()
            maxisochrones_memorylayer_pr.addAttributes([
                                              QgsField("MaxIsochrone_Time",QVariant.Int),
                                              QgsField("MaxIsochrone_UID", QVariant.Int),
                                              QgsField("MaxIsochrone_ID", QVariant.Int),
                                              QgsField("MaxIsochrone_Error", QVariant.String),
                                              QgsField("MaxIsochrone_URL", QVariant.String)
                                              ]) # Add Error and URL Field to outputlayer
            maxisochrones_memorylayer_pr.addAttributes(self.gf.maxisochrones_selectedlayer.fields()) # Copy all fieldnames of inputlayer to outputlayer  
            inputlayer_numberoffields = self.gf.maxisochrones_selectedlayer.fields().count() # count number of fields in inputlayer
            inputlayer_outfeat = QgsFeature() # set QgsFeature
            
            # Savelocation
            tmp_save_location = self.gf.tmp_save_location
    
            # General Settings
            serverurl = self.gf.serverurl #'https://api.digitransit.fi/routing/v1/routers/hsl/' #self.dlg.GeneralSettings_ServerURL.toPlainText()        
     
            # Preparing Transformation to WGS 84
            sourcecrs = QgsCoordinateReferenceSystem(self.gf.maxisochrones_selectedlayer.crs().authid()) # Read CRS of input layer
            destcrs = QgsCoordinateReferenceSystem("EPSG:4326") # and set destination CRS to WGS 84 (OTP can only understand EPSG:4326) 
            tr = QgsCoordinateTransform(sourcecrs, destcrs, QgsProject.instance()) # Setting up transformation
            
            # Preparing Progressbar
            progressbar_featurecount = self.gf.maxisochrones_selectedlayer.featureCount()
            progressbar_percent = 1 # Use 1 on start to show users that something is running if the first one takes a while
            progressbar_counter = 0
            self.maxisochrones_progress.emit(int(progressbar_percent))
            
            if progressbar_featurecount == 0:
                self.maxisochrones_state = 3
                QgsMessageLog.logMessage("Warning! No Isochrones to create. Inputlayer is empty.",MESSAGE_CATEGORY,Qgis.Warning)
                self.maxisochrones_progress.emit(int(0))
                
            for inputlayer_feature in inputlayer_features:
                if self.stopmaxisochronesworker == True: # if cancel button has been clicked this var has been set to True to break the loop so the thread can be quit
                    self.maxisochrones_state = 2
                    break
                
                # Initial Variables
                # Empty the error vars
                isochrone_error = None
                isochrone_errors = []
                isochrone_unique_errors = []
                
                progressbar_counter = progressbar_counter + 1
                    
                # retrieve every feature with its geometry and attributes
                QgsMessageLog.logMessage("Feature ID: " + str(inputlayer_feature.id()),MESSAGE_CATEGORY,Qgis.Info)
                
                # Override Button Feature
                ctx.setFeature(inputlayer_feature) #Setting context to current feature
                
                # Feature Geometry
                geom = inputlayer_feature.geometry() # fetch geometry of current feature
                geom.transform(tr) # Transform geometry to WGS 84 (We prepared this outside the loop)
                pointgeom = geom.asPoint() #Read Point geometry
                x = round(pointgeom.x(),8) #Read X-Value
                y = round(pointgeom.y(),8) #Read Y-Value
                QgsMessageLog.logMessage("PointX: " + str(x) + " | PointY: " + str(y),MESSAGE_CATEGORY,Qgis.Info)
                
                # Feature Attributes
                Inputlayer_Attributes = inputlayer_feature.attributes() # fetch attributes
                
                # Copy Attributes to outputlayer
                inputlayer_outfeat.setAttributes(inputlayer_feature.attributes()) # set the attributes
                
                #Check where to gather attributes from: GUI or Layer? 
                #WalkSpeed
                if self.dlg.MaxIsochrones_WalkSpeed_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.MaxIsochrones_WalkSpeed_Override.isActive() == True: # Check if override button shall be used
                        maxisochrones_walkspeed_value, irrelevantsuccessstorage = self.dlg.MaxIsochrones_WalkSpeed_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        maxisochrones_walkspeed_value = self.dlg.MaxIsochrones_WalkSpeed.value() # Receiving Value from GUI: QDoubleSpinBox
                    if maxisochrones_walkspeed_value is not None: # Check if received value is NULL
                        maxisochrones_walkspeed_ms = float(maxisochrones_walkspeed_value) * 0.27777777777778 # Convert float and km/h to m/s
                        maxisochrones_walkspeed_urlstring = '&walkSpeed=' + str(round(maxisochrones_walkspeed_ms,6)) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        maxisochrones_walkspeed_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    maxisochrones_walkspeed_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
     
                #BikeSpeed
                if self.dlg.MaxIsochrones_BikeSpeed_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.MaxIsochrones_BikeSpeed_Override.isActive() == True: # Check if override button shall be used
                        maxisochrones_bikespeed_value, irrelevantsuccessstorage = self.dlg.MaxIsochrones_BikeSpeed_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        maxisochrones_bikespeed_value = self.dlg.MaxIsochrones_BikeSpeed.value() # Receiving Value from GUI: QDoubleSpinBox
                    if maxisochrones_bikespeed_value is not None: # Check if received value is NULL
                        maxisochrones_bikespeed_ms = float(maxisochrones_bikespeed_value) * 0.27777777777778 # Convert float and km/h to m/s
                        maxisochrones_bikespeed_urlstring = '&bikeSpeed=' + str(round(maxisochrones_bikespeed_ms,6)) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        maxisochrones_bikespeed_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    maxisochrones_bikespeed_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                    
                #ArriveBy
                if self.dlg.MaxIsochrones_ArriveBy_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.MaxIsochrones_ArriveBy_Override.isActive() == True: # Check if override button shall be used
                        maxisochrones_arriveby_value, irrelevantsuccessstorage = self.dlg.MaxIsochrones_ArriveBy_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        maxisochrones_arriveby_value = self.dlg.MaxIsochrones_ArriveBy.isChecked() # Receiving Value from GUI: QCheckBox
                    if maxisochrones_arriveby_value is not None: # Check if received value is NULL
                        maxisochrones_arriveby_urlstring = '&arriveBy=' + str(maxisochrones_arriveby_value) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        maxisochrones_arriveby_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    maxisochrones_arriveby_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                    
                #Wheelchair
                if self.dlg.MaxIsochrones_Wheelchair_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.MaxIsochrones_Wheelchair_Override.isActive() == True: # Check if override button shall be used
                        maxisochrones_wheelchair_value, irrelevantsuccessstorage = self.dlg.MaxIsochrones_Wheelchair_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        maxisochrones_wheelchair_value = self.dlg.MaxIsochrones_Wheelchair.isChecked() # Receiving Value from GUI: QCheckBox
                    if maxisochrones_wheelchair_value is not None: # Check if received value is NULL
                        maxisochrones_wheelchair_urlstring = '&wheelchair=' + str(maxisochrones_wheelchair_value) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        maxisochrones_wheelchair_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    maxisochrones_wheelchair_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                    
                #WaitReluctance
                if self.dlg.MaxIsochrones_WaitReluctance_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.MaxIsochrones_WaitReluctance_Override.isActive() == True: # Check if override button shall be used
                        maxisochrones_waitreluctance_value, irrelevantsuccessstorage = self.dlg.MaxIsochrones_WaitReluctance_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        maxisochrones_waitreluctance_value = self.dlg.MaxIsochrones_WaitReluctance.value() # Receiving Value from GUI: QDoubleSpinBox
                    if maxisochrones_waitreluctance_value is not None: # Check if received value is NULL
                        maxisochrones_waitreluctance_float = round(float(maxisochrones_waitreluctance_value),2)
                        maxisochrones_waitreluctance_urlstring = '&waitReluctance=' + str(maxisochrones_waitreluctance_float) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        maxisochrones_waitreluctance_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    maxisochrones_waitreluctance_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                    
                #MaxTransfers
                if self.dlg.MaxIsochrones_MaxTransfers_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.MaxIsochrones_MaxTransfers_Override.isActive() == True: # Check if override button shall be used
                        maxisochrones_maxtransfers_value, irrelevantsuccessstorage = self.dlg.MaxIsochrones_MaxTransfers_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        maxisochrones_maxtransfers_value = self.dlg.MaxIsochrones_MaxTransfers.value() # Receiving Value from GUI: QSpinBox
                    if maxisochrones_maxtransfers_value is not None: # Check if received value is NULL
                        maxisochrones_maxtransfers_urlstring = '&maxTransfers=' + str(maxisochrones_maxtransfers_value) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        maxisochrones_maxtransfers_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    maxisochrones_maxtransfers_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                 
                #MaxWalkDistance
                if self.dlg.MaxIsochrones_MaxWalkDistance_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.MaxIsochrones_MaxWalkDistance_Override.isActive() == True: # Check if override button shall be used
                        maxisochrones_maxwalkdistance_value, irrelevantsuccessstorage = self.dlg.MaxIsochrones_MaxWalkDistance_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        maxisochrones_maxwalkdistance_value = self.dlg.MaxIsochrones_MaxWalkDistance.value() # Receiving Value from GUI: QSpinBox
                    if maxisochrones_maxwalkdistance_value is not None: # Check if received value is NULL
                        maxisochrones_maxwalkdistance_urlstring = '&maxWalkDistance=' + str(maxisochrones_maxwalkdistance_value) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        maxisochrones_maxwalkdistance_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    maxisochrones_maxwalkdistance_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                 
                #MaxOffroadDistance
                if self.dlg.MaxIsochrones_MaxOffroadDistance_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.MaxIsochrones_MaxOffroadDistance_Override.isActive() == True: # Check if override button shall be used
                        maxisochrones_maxoffroaddistance_value, irrelevantsuccessstorage = self.dlg.MaxIsochrones_MaxOffroadDistance_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        maxisochrones_maxoffroaddistance_value = self.dlg.MaxIsochrones_MaxOffroadDistance.value() # Receiving Value from GUI: QSpinBox
                    if maxisochrones_maxoffroaddistance_value is not None: # Check if received value is NULL
                        maxisochrones_maxoffroaddistance_urlstring = '&offRoadDistanceMeters=' + str(maxisochrones_maxoffroaddistance_value) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        maxisochrones_maxoffroaddistance_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    maxisochrones_maxoffroaddistance_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                 
                #PrecisionMeters
                if self.dlg.MaxIsochrones_PrecisionMeters_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.MaxIsochrones_PrecisionMeters_Override.isActive() == True: # Check if override button shall be used
                        maxisochrones_precisionmeters_value, irrelevantsuccessstorage = self.dlg.MaxIsochrones_PrecisionMeters_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        maxisochrones_precisionmeters_value = self.dlg.MaxIsochrones_PrecisionMeters.value() # Receiving Value from GUI: QSpinBox
                    if maxisochrones_precisionmeters_value is not None: # Check if received value is NULL
                        maxisochrones_precisionmeters_urlstring = '&precisionMeters=' + str(maxisochrones_precisionmeters_value) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        maxisochrones_precisionmeters_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    maxisochrones_precisionmeters_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)                   
    
                #Isochrones Interval
                if self.dlg.MaxIsochrones_Interval_Override.isActive() == True:
                    maxisochrones_interval_value, irrelevantsuccessstorage = self.dlg.MaxIsochrones_Interval_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    maxisochrones_interval_value = self.dlg.MaxIsochrones_Interval.toPlainText() #Receiving Value from GUI: QTextEdit
                if not maxisochrones_interval_value: # Check if it is NULL
                    maxisochrones_interval_value = '300,600,900' # Make sure cutoffSec is not empty because it is a must have parameter   
                maxisochrones_interval_value = maxisochrones_interval_value.replace(" ", "")  # Remove whitespaces in case user entered them              
                interval_list = list(maxisochrones_interval_value.split(",")) # Split given Integers (as string) separated by comma into a list
                interval_list_new = []
                for entry in interval_list:
                    if entry.lower().endswith('m'):
                        entry = str(int(entry.lower().replace('m',''))*60)
                    elif entry.lower().endswith('h'):
                        entry = str(int(entry.lower().replace('h',''))*3600)
                    interval_list_new.append(entry)
                maxisochrones_interval_urlstring = "&cutoffSec=".join(interval_list_new) #Join the list to a string and add leading "&cutoffSec=" to each Integer. The first item of the list will get no leading "&cutoffSec=", we will add this later
    
                #Transportation Mode
                if self.dlg.MaxIsochrones_TransportationMode_Override.isActive() == True:
                    maxisochrones_transportationmode_value, irrelevantsuccessstorage = self.dlg.MaxIsochrones_TransportationMode_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    maxisochrones_transportationmode_value = self.dlg.MaxIsochrones_TransportationMode.toPlainText() #Receiving Value from GUI: QTextEdit
                if not maxisochrones_transportationmode_value: # Check if it is NULL
                    maxisochrones_transportationmode_value = 'WALK,TRANSIT' # Make sure Mode is not empty because it is a must have parameter
                maxisochrones_transportationmode_urlstring = "&mode=" + maxisochrones_transportationmode_value.upper() # Make sure Mode is given as uppercase to prevent possible server errors (not sure how otp handels this exactly)
                
                #Additional Parameters
                if self.dlg.MaxIsochrones_AdditionalParameters_Override.isActive() == True:
                    maxisochrones_additionalparameters_value, irrelevantsuccessstorage = self.dlg.MaxIsochrones_AdditionalParameters_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    maxisochrones_additionalparameters_value = self.dlg.MaxIsochrones_AdditionalParameters.toPlainText() #Receiving Value from GUI: QTextEdit
                if maxisochrones_additionalparameters_value is not None: # If Additional Parameters are filled, use it
                    maxisochrones_additionalparameters_urlstring = str(maxisochrones_additionalparameters_value) # Create the string
                else: # If Additional Parameters are not filled, do not use it
                    maxisochrones_additionalparameters_urlstring = '' # Create the string (Empty, because it is not used, not NULL!!)
                    
                ##################################
                
                #From DateTime
                if self.dlg.MaxIsochrones_FromDateTime_Override.isActive() == True: # Check if override button shall be used
                    maxisochrones_fromdatetime_value, irrelevantsuccessstorage = self.dlg.MaxIsochrones_FromDateTime_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    maxisochrones_fromdatetime_value = self.dlg.MaxIsochrones_FromDateTime.dateTime().toString("yyyy-MM-dd HH:mm:ss") # Receiving Value from GUI: QDateTime
                maxisochrones_fromdatetime_value = datetime.strptime(maxisochrones_fromdatetime_value, '%Y-%m-%d %H:%M:%S')
                    
                #To DateTime
                if self.dlg.MaxIsochrones_ToDateTime_Override.isActive() == True: # Check if override button shall be used
                    maxisochrones_todatetime_value, irrelevantsuccessstorage = self.dlg.MaxIsochrones_ToDateTime_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    maxisochrones_todatetime_value = self.dlg.MaxIsochrones_ToDateTime.dateTime().toString("yyyy-MM-dd HH:mm:ss") # Receiving Value from GUI: QDateTime
                maxisochrones_todatetime_value = datetime.strptime(maxisochrones_todatetime_value, '%Y-%m-%d %H:%M:%S')
                
                #RequestInterval             
                if self.dlg.MaxIsochrones_RequestInterval_Override.isActive() == True: # Check if override button shall be used
                    maxisochrones_requestinterval_value, irrelevantsuccessstorage = self.dlg.MaxIsochrones_RequestInterval_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    maxisochrones_requestinterval_value = self.dlg.MaxIsochrones_RequestInterval.value() # Receiving Value from GUI: QSpinBox
                
                QgsMessageLog.logMessage('maxisochrones_requestinterval_value: ' + str(maxisochrones_requestinterval_value) + 
                                         " maxisochrones_requestinterval_value: " + str(maxisochrones_requestinterval_value) + 
                                         " maxisochrones_todatetime_value: " + str(maxisochrones_todatetime_value) + 
                                         " maxisochrones_fromdatetime_value: " + str(maxisochrones_fromdatetime_value)
                                         ,MESSAGE_CATEGORY,Qgis.Warning)
                #Cancel execution if....:
                if (not maxisochrones_requestinterval_value or maxisochrones_requestinterval_value < 1 or maxisochrones_todatetime_value < maxisochrones_fromdatetime_value):
                    self.maxisochrones_state = 4
                    QgsMessageLog.logMessage("Warning! There is something wrong with your DateTime-Settings, check them and try again.",MESSAGE_CATEGORY,Qgis.Warning)
                    break
                
                # Iterating over the datetimes
                intervalseconds = (maxisochrones_todatetime_value - maxisochrones_fromdatetime_value).seconds
                intervaliteration = 0
                tmp_maxisochrones_vl = None
                QgsMessageLog.logMessage('Intervalseconds: ' + str(intervalseconds) + " Requestintervalvalue: " + str(maxisochrones_requestinterval_value),MESSAGE_CATEGORY,Qgis.Warning)
                for currentsecond in range(0,intervalseconds,maxisochrones_requestinterval_value):
                    intervaliteration += 1
                    if self.stopmaxisochronesworker == True: # if cancel button has been clicked this var has been set to True to break the loop so the thread can be quit
                        self.maxisochrones_state = 2
                        break
                    
                    maxisochrones_currentdatetime_value = (maxisochrones_fromdatetime_value + timedelta(seconds = currentsecond))
                    maxisochrones_currentdatetime_string = maxisochrones_currentdatetime_value.strftime("%Y-%m-%d %H:%M:%S")
                    maxisochrones_currentdate_string = maxisochrones_currentdatetime_value.strftime("%Y-%m-%d")
                    maxisochrones_currenttime_string = maxisochrones_currentdatetime_value.strftime("%H:%M:%S")
                    maxisochrones_currentdate_urlstring = '&date=' + str(maxisochrones_currentdate_string)
                    maxisochrones_currenttime_urlstring = '&time=' + str(maxisochrones_currenttime_string)
                    
                    if intervaliteration == 1: # Create temporary polygon layer we can dissolve later to get the maximum
                        tmp_maxisochrones_vl = QgsVectorLayer("MultiPolygon?crs=epsg:4326", "TmpMaxIsochrones", "memory")
                        tmp_maxisochrones_pr = tmp_maxisochrones_vl.dataProvider()
                        with edit(tmp_maxisochrones_vl):
                            tmp_maxisochrones_pr.addAttributes([QgsField("time",QVariant.Int)])
                    
                    with edit(tmp_maxisochrones_vl):
                        #Working example: https://api.digitransit.fi/routing/v1/routers/hsl/isochrone?fromPlace=60.169,24.938&mode=WALK,TRANSIT&date=2019-11-01&time=08:00:00&maxWalkDistance=500&cutoffSec=1800&cutoffSec=3600
                        #Concat URL and convert to string
                        isochrone_url = (str(serverurl) + "isochrone?algorithm=accSampling" + # Add Isochrones request and algorithm to server url
                                        "&fromPlace=" + str(y) + "," + str(x) + # concatenate x and y coordinates as string
                                        maxisochrones_transportationmode_urlstring + #
                                        maxisochrones_walkspeed_urlstring + #
                                        maxisochrones_bikespeed_urlstring + #
                                        maxisochrones_currentdate_urlstring + #
                                        maxisochrones_currenttime_urlstring + #
                                        maxisochrones_arriveby_urlstring + #
                                        maxisochrones_wheelchair_urlstring + #
                                        maxisochrones_waitreluctance_urlstring + #
                                        maxisochrones_maxtransfers_urlstring + #
                                        maxisochrones_maxwalkdistance_urlstring + #
                                        maxisochrones_maxoffroaddistance_urlstring + #
                                        maxisochrones_precisionmeters_urlstring + #
                                        maxisochrones_additionalparameters_urlstring + # Additional Parameters entered as OTP-Readable string -> User responsibility
                                        "&cutoffSec=" + str(maxisochrones_interval_urlstring) # Interval-Integers are taken as comma separated string, then split into list and then joined to string with leading "&cutoffSec=". The first interval therefore has no leading "&cutoffSec=" thats why we add it here
                                        )
                        QgsMessageLog.logMessage('Intervaliteration: ' + str(intervaliteration) + " of Feature ID: " + str(inputlayer_feature.id()) + ' at DateTime: ' + str(maxisochrones_currentdatetime_string) + '\nwith URL: ' + str(isochrone_url),MESSAGE_CATEGORY,Qgis.Info)
                        debug_info = "Feature ID: " + str(inputlayer_feature.id()) + ' at iteration: ' + str(intervaliteration) + ' with URL: ' + str(isochrone_url) + '\n'
                        
                        #request and download file
                        isochrone_responseLayer = None
                        try:
                            isochrone_headers = {"accept":"application/x-zip-compressed"}
                            isochrone_request = urllib.request.Request(isochrone_url, headers=isochrone_headers)
                            isochrone_response = urllib.request.urlopen(isochrone_request, timeout=self.gf.timeout_setting)
                            # Sending request to server. Using shapefiles to avoid invalid geometries on high level of detail + geojson throwback seems to be limited to 4 decimals.
                        #save file
                            try:
                                with open(tmp_save_location + 'isochrones.zip', 'wb') as f: # Write shapefile to temp location
                                    f.write(isochrone_response.read())
                                    #f.write(r.content) # write zip content
                        #unzip file
                                try:
                                    with zipfile.ZipFile(tmp_save_location + 'isochrones.zip', 'r') as zip_ref:
                                        zip_ref.extractall(tmp_save_location) 
                        #load file
                                    try:
                                        isochrone_responseLayer = QgsVectorLayer(tmp_save_location + "null.shp", "null", "ogr") # load just downloaded file as vector layer
                                        isochrone_responseLayer.updateExtents()
                                    except Exception as e:
                                        isochrone_error = f'Error: loading response failed (Exception {str(e)})'
                                        isochrone_errors.append(isochrone_error)
                                except Exception as e:
                                    isochrone_error = f'Error: response file not valid (Exception {str(e)})'
                                    isochrone_errors.append(isochrone_error)
                            except Exception as e:
                                isochrone_error = f'Error: writing response to harddrive failed (Exception {str(e)})'
                                isochrone_errors.append(isochrone_error)
                        except Exception as e:
                            isochrone_error = f'Error: request failed (Exception {str(e)})' 
                            isochrone_errors.append(isochrone_error)

                        # Check Validity of Responselayer
                        try:
                            if not isochrone_responseLayer:
                                isochrone_error = 'Error: response layer does not exist'
                                isochrone_errors.append(isochrone_error)
                            elif (not isochrone_responseLayer.isValid()) or (isochrone_responseLayer.extent().yMaximum() == 0.0) or (isochrone_responseLayer.extent().xMaximum() == 0.0) or (isochrone_responseLayer.extent().yMinimum() == 0.0) or (isochrone_responseLayer.extent().xMinimum() == 0.0):
                                isochrone_error = 'Error: response layer is not valid'
                                isochrone_errors.append(isochrone_error)
                        except Exception as e:
                            isochrone_error = f'Error: response layer is not valid (Exception {str(e)})'
                            isochrone_errors.append(isochrone_error)
                        
                        # Cancel this isochrone on errors
                        if isochrone_errors:
                            continue
                        
                        #get features of file
                        isochrone_features = isochrone_responseLayer.getFeatures() # get features of just downloaded isochrone 
                        
                        #iterate trough isochrone
                        for isochrone_feature in isochrone_features:
                            tmp_maxisochrones_pr.addFeature(isochrone_feature) # copy features of responselayer including geometry and attributes (it is always only one attribute) to new layer  
                        tmp_maxisochrones_vl.updateFields()
                        tmp_maxisochrones_vl.updateExtents()
                        
                    # END OF EDIT TEMP LAYER
                
                # END OF TIME ITERATION
                
                # Throw back final status on this one
                if maxisochrone_errors:
                    maxisochrone_unique_errors = set(maxisochrone_errors)
                    maxisochrone_unique_errors = list(maxisochrone_unique_errors)
                    unique_errors.extend(maxisochrone_unique_errors)
                    QgsMessageLog.logMessage('Isochrone Errors: ' + str("; ".join(maxisochrone_unique_errors)),MESSAGE_CATEGORY,Qgis.Warning)
                    
                # Dissolve the temp-layer
                dissolve_tmplayer = processing.run("native:dissolve", {'FIELD':['time'], 'INPUT':tmp_maxisochrones_vl, 'OUTPUT':'TEMPORARY_OUTPUT'})
                tmp_maxisochrones_vl = dissolve_tmplayer['OUTPUT']
                
                # Check Validity
                try:
                    if not tmp_maxisochrones_vl:
                        tmp_maxisochrones_error = 'Error: dissolved layer does not exist'
                        tmp_maxisochrones_errors.append(tmp_maxisochrones_error)
                    elif (not tmp_maxisochrones_vl.isValid()) or (tmp_maxisochrones_vl.extent().yMaximum() == 0.0) or (tmp_maxisochrones_vl.extent().xMaximum() == 0.0) or (tmp_maxisochrones_vl.extent().yMinimum() == 0.0) or (tmp_maxisochrones_vl.extent().xMinimum() == 0.0):
                        tmp_maxisochrones_error = 'Error: dissolved layer is not valid'
                        tmp_maxisochrones_errors.append(tmp_maxisochrones_error)
                except Exception as e:
                    tmp_maxisochrones_error = f'Error: dissolved layer is not valid (Exception {str(e)})'
                    tmp_maxisochrones_errors.append(tmp_maxisochrones_error)
                
                # Create Dummylayer on Error to prevent errors in code or broken result layer
                if tmp_maxisochrones_errors:
                    tmp_maxisochrones_vl = QgsVectorLayer("MultiPolygon?crs=epsg:4326","Errorlayer","memory")
                    tmp_maxisochrones_vl_pr = tmp_maxisochrones_vl.dataProvider()
                    tmp_maxisochrones_vl.startEditing()
                    error_feature = QgsFeature()
                    error_feature.setGeometry(QgsGeometry.fromWkt("Polygon ((-0.1 -0.1, -0.1 0.1, 0.1 0.1, 0.1 -0.1, -0.1 -0.1))"))
                    tmp_maxisochrones_vl_pr.addAttributes([QgsField("time",QVariant.Int)])
                    for j in interval_list:
                        tmp_maxisochrones_vl_pr.addFeatures([error_feature])
                    tmp_maxisochrones_vl.commitChanges()
                    tmp_maxisochrones_vl.updateExtents()
                    
                #get features of file
                maxisochrone_features = tmp_maxisochrones_vl.getFeatures() # get features of just downloaded isochrone 
                
                #iterate trough isochrone
                maxisochrone_id_counter = maxisochrone_id_counter + 1
                for maxisochrone_feature in maxisochrone_features:
                    maxisochrone_uid_counter = maxisochrone_uid_counter + 1
                    maxisochrones_memorylayer_pr.addFeature(maxisochrone_feature) # copy features of responselayer including geometry and attributes (it is always only one attribute) to new layer  
                    attrs_maxisochrone = { 1 : maxisochrone_uid_counter,
                                           2 : maxisochrone_id_counter,
                                           3 : str("; ".join(maxisochrone_unique_errors)) if maxisochrone_errors else None,
                                           4 : maxisochrone_url } # set further generic attributes
                    maxisochrones_memorylayer_pr.changeAttributeValues({ maxisochrone_feature.id() : attrs_maxisochrone }) # change attribute values of new layer to the just set ones  
                    for i in range(0, inputlayer_numberoffields): # iterate over new layer as many fields as the input layer has                
                        attrs_inputlayer = { i + 5 : Inputlayer_Attributes[i] } # set attributes of inputlayer (+5 because we added 5 new fields before)
                        maxisochrones_memorylayer_pr.changeAttributeValues({ maxisochrone_feature.id() : attrs_inputlayer }) # change attribute values of new layer to the ones from inputlayer 
                        if maxisochrone_error: # change stuff to null/dummy if isochrone is not valid
                            err_attrs_maxisochrone = { 0 : 0 } # set time field to 0 on error
                            maxisochrones_memorylayer_pr.changeAttributeValues({ maxisochrone_feature.id() : err_attrs_maxisochrone }) # set time field to 0 on error
                            nullgeom = QgsGeometry.fromWkt("Polygon ((-0.1 -0.1, -0.1 0.1, 0.1 0.1, 0.1 -0.1, -0.1 -0.1))") # create pseudopolygon
                            #nullgeom = QgsGeometry.fromWkt('') #causes issues with layer. Just stick to pseudopolygon
                            maxisochrones_memorylayer_pr.changeGeometryValues({ maxisochrone_feature.id() : nullgeom }) # set geometry of feature to null on error 


                maxisochrones_memorylayer_vl.updateFields()
                maxisochrones_memorylayer_vl.updateExtents()
                
                # Update Progressbar
                progressbar_percent = progressbar_counter / float(progressbar_featurecount) * 100
                self.maxisochrones_progress.emit(int(progressbar_percent))
                
                QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info)
                QgsMessageLog.logMessage("-----",MESSAGE_CATEGORY,Qgis.Info)
                QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info)
                
            #END OF INPUTLAYER FEATURE LOOP
            
            # Isochrones Memory VectorLayer
            maxisochrones_memorylayer_vl.updateFields()
            maxisochrones_memorylayer_vl.updateExtents()

        unique_errors = set(unique_errors)
        unique_errors = list(unique_errors)
        unique_errors = '; '.join(unique_errors)
        maxisochrones_endtime = datetime.now()
        maxisochrones_runtime = maxisochrones_endtime - maxisochrones_starttime
        if self.stopmaxisochronesworker == True:
            QgsMessageLog.logMessage("##### Max-Isochrones job canceled by user after " + str(maxisochrones_runtime) + " @ " + str(datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")) + " #####",MESSAGE_CATEGORY,Qgis.Info)
        else:
            QgsMessageLog.logMessage("##### Max-Isochrones job done in " + str(maxisochrones_runtime) + " @ " + str(datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")) + " #####",MESSAGE_CATEGORY,Qgis.Info)
        QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info)

        self.maxisochrones_finished.emit(maxisochrones_memorylayer_vl, self.maxisochrones_state, str(unique_errors), str(maxisochrones_runtime))
