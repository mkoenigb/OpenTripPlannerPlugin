# -*- coding: utf-8 -*-
"""
/***************************************************************************
 OpenTripPlannerPlugin
                                 A QGIS plugin
 This plugin makes OpenTripPlanner functionalities accessible in QGIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-10-21
        git sha              : $Format:%H$
        copyright            : (C) 2019 - Today by Mario KÃ¶nigbauer
        email                : mkoenigb@gmx.de
        repository           : https://github.com/mkoenigb/OpenTripPlannerPlugin
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QObject, QThread, pyqtSignal
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog
from PyQt5.QtNetwork import  QNetworkAccessManager, QNetworkRequest
from PyQt5.QtCore import *
from qgis.core import *
from qgis.utils import *


# Initialize Qt resources from file resources.py
from .resources import *
from .otp_plugin_general_functions import *
# Import the code for the dialog
from .otp_plugin_dialog import OpenTripPlannerPluginDialog
from osgeo import ogr
from datetime import *
import processing
import os
import urllib
import zipfile
import json

MESSAGE_CATEGORY = 'OpenTripPlanner PlugIn'

class OpenTripPlannerPluginAggregatedIsochronesWorker(QThread):
    aggregated_isochrones_finished = pyqtSignal(object, int, str, str)
    aggregated_isochrones_progress = pyqtSignal(int)

    def __init__(self, dialog, iface, otpgf, resultlayer):
        super(QThread, self).__init__()
        self.dlg = dialog
        self.gf = otpgf
        self.iface = iface
        self.stopaggregated_isochronesworker = False
        self.aggregated_isochrones_memorylayer_vl = resultlayer
        self.aggregated_isochrones_state = 0
        self.gf.read_general_variables()
        #self.gf.read_isochrone_variables()
    
    def stop(self):
        self.stopaggregated_isochronesworker = True

        
    def run(self):        
        # clear and initialize vars and stuff
        self.aggregated_isochrones_state = 1
        aggregated_isochrone_url = None
        aggregated_isochrone_error = None
        aggregated_isochrone_errors = []
        tmp_aggregated_isochrones_error = None
        tmp_aggregated_isochrones_errors = []
        unique_errors = []
        r = None
        inputlayer_outfeat = None
        debug_info = None
        aggregated_isochrone_uid_counter = 0
        aggregated_isochrone_id_counter = 0
        aggregated_isochrones_memorylayer_vl = self.aggregated_isochrones_memorylayer_vl
        
        QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info)
        QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info)
        QgsMessageLog.logMessage("##### Max-Isochrones job starting @ " + str(datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")) + " #####",MESSAGE_CATEGORY,Qgis.Info)
        QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info)
        aggregated_isochrones_starttime = datetime.now()
        
        
        # Setting up Override Button context
        ctx = QgsExpressionContext(QgsExpressionContextUtils.globalProjectLayerScopes(self.gf.aggregated_isochrones_selectedlayer)) #This context will be able to evaluate global, project, and layer variables
        
        # Preparing Features
        inputlayer_features = self.gf.aggregated_isochrones_selectedlayer.getFeatures()
        
        # Create the Output-Vectorlayer
        with edit(aggregated_isochrones_memorylayer_vl):
            aggregated_isochrones_memorylayer_pr = aggregated_isochrones_memorylayer_vl.dataProvider()
            aggregated_isochrones_memorylayer_pr.addAttributes([
                                              QgsField("AggregatedIsochrone_Time",QVariant.Int),
                                              QgsField("AggregatedIsochrone_UID", QVariant.Int),
                                              QgsField("AggregatedIsochrone_ID", QVariant.Int),
                                              QgsField("AggregatedIsochrone_Error", QVariant.String),
                                              QgsField("AggregatedIsochrone_URL", QVariant.String)
                                              ]) # Add Error and URL Field to outputlayer
            aggregated_isochrones_memorylayer_pr.addAttributes(self.gf.aggregated_isochrones_selectedlayer.fields()) # Copy all fieldnames of inputlayer to outputlayer  
            inputlayer_numberoffields = self.gf.aggregated_isochrones_selectedlayer.fields().count() # count number of fields in inputlayer
            inputlayer_outfeat = QgsFeature() # set QgsFeature
            
            # Savelocation
            tmp_save_location = self.gf.tmp_save_location
    
            # General Settings
            serverurl = self.gf.serverurl #'https://api.digitransit.fi/routing/v1/routers/hsl/' #self.dlg.GeneralSettings_ServerURL.toPlainText()        
     
            # Preparing Transformation to WGS 84
            sourcecrs = QgsCoordinateReferenceSystem(self.gf.aggregated_isochrones_selectedlayer.crs().authid()) # Read CRS of input layer
            destcrs = QgsCoordinateReferenceSystem("EPSG:4326") # and set destination CRS to WGS 84 (OTP can only understand EPSG:4326) 
            tr = QgsCoordinateTransform(sourcecrs, destcrs, QgsProject.instance()) # Setting up transformation
            
            # Preparing Progressbar
            progressbar_featurecount = self.gf.aggregated_isochrones_selectedlayer.featureCount()
            progressbar_percent = 1 # Use 1 on start to show users that something is running if the first one takes a while
            progressbar_counter = 0
            self.aggregated_isochrones_progress.emit(int(progressbar_percent))
            
            if progressbar_featurecount == 0:
                self.aggregated_isochrones_state = 3
                QgsMessageLog.logMessage("Warning! No Isochrones to create. Inputlayer is empty.",MESSAGE_CATEGORY,Qgis.Warning)
                self.aggregated_isochrones_progress.emit(int(0))
                
            for inputlayer_feature in inputlayer_features:
                if self.stopaggregated_isochronesworker == True: # if cancel button has been clicked this var has been set to True to break the loop so the thread can be quit
                    self.aggregated_isochrones_state = 2
                    break
                
                # Initial Variables
                # Empty the error vars
                isochrone_error = None
                isochrone_errors = []
                isochrone_unique_errors = []
                
                progressbar_counter = progressbar_counter + 1
                    
                # retrieve every feature with its geometry and attributes
                QgsMessageLog.logMessage("Feature ID: " + str(inputlayer_feature.id()),MESSAGE_CATEGORY,Qgis.Info)
                
                # Override Button Feature
                ctx.setFeature(inputlayer_feature) #Setting context to current feature
                
                # Feature Geometry
                geom = inputlayer_feature.geometry() # fetch geometry of current feature
                geom.transform(tr) # Transform geometry to WGS 84 (We prepared this outside the loop)
                pointgeom = geom.asPoint() #Read Point geometry
                x = round(pointgeom.x(),8) #Read X-Value
                y = round(pointgeom.y(),8) #Read Y-Value
                QgsMessageLog.logMessage("PointX: " + str(x) + " | PointY: " + str(y),MESSAGE_CATEGORY,Qgis.Info)
                
                # Feature Attributes
                Inputlayer_Attributes = inputlayer_feature.attributes() # fetch attributes
                
                # Copy Attributes to outputlayer
                inputlayer_outfeat.setAttributes(inputlayer_feature.attributes()) # set the attributes
                
                #Check where to gather attributes from: GUI or Layer? 
                #WalkSpeed
                if self.dlg.AggregatedIsochrones_WalkSpeed_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.AggregatedIsochrones_WalkSpeed_Override.isActive() == True: # Check if override button shall be used
                        aggregated_isochrones_walkspeed_value, irrelevantsuccessstorage = self.dlg.AggregatedIsochrones_WalkSpeed_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        aggregated_isochrones_walkspeed_value = self.dlg.AggregatedIsochrones_WalkSpeed.value() # Receiving Value from GUI: QDoubleSpinBox
                    if aggregated_isochrones_walkspeed_value is not None: # Check if received value is NULL
                        aggregated_isochrones_walkspeed_ms = float(aggregated_isochrones_walkspeed_value) * 0.27777777777778 # Convert float and km/h to m/s
                        aggregated_isochrones_walkspeed_urlstring = '&walkSpeed=' + str(round(aggregated_isochrones_walkspeed_ms,6)) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        aggregated_isochrones_walkspeed_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    aggregated_isochrones_walkspeed_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
     
                #BikeSpeed
                if self.dlg.AggregatedIsochrones_BikeSpeed_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.AggregatedIsochrones_BikeSpeed_Override.isActive() == True: # Check if override button shall be used
                        aggregated_isochrones_bikespeed_value, irrelevantsuccessstorage = self.dlg.AggregatedIsochrones_BikeSpeed_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        aggregated_isochrones_bikespeed_value = self.dlg.AggregatedIsochrones_BikeSpeed.value() # Receiving Value from GUI: QDoubleSpinBox
                    if aggregated_isochrones_bikespeed_value is not None: # Check if received value is NULL
                        aggregated_isochrones_bikespeed_ms = float(aggregated_isochrones_bikespeed_value) * 0.27777777777778 # Convert float and km/h to m/s
                        aggregated_isochrones_bikespeed_urlstring = '&bikeSpeed=' + str(round(aggregated_isochrones_bikespeed_ms,6)) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        aggregated_isochrones_bikespeed_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    aggregated_isochrones_bikespeed_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                    
                #ArriveBy
                if self.dlg.AggregatedIsochrones_ArriveBy_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.AggregatedIsochrones_ArriveBy_Override.isActive() == True: # Check if override button shall be used
                        aggregated_isochrones_arriveby_value, irrelevantsuccessstorage = self.dlg.AggregatedIsochrones_ArriveBy_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        aggregated_isochrones_arriveby_value = self.dlg.AggregatedIsochrones_ArriveBy.isChecked() # Receiving Value from GUI: QCheckBox
                    if aggregated_isochrones_arriveby_value is not None: # Check if received value is NULL
                        aggregated_isochrones_arriveby_urlstring = '&arriveBy=' + str(aggregated_isochrones_arriveby_value) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        aggregated_isochrones_arriveby_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    aggregated_isochrones_arriveby_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                    
                #Wheelchair
                if self.dlg.AggregatedIsochrones_Wheelchair_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.AggregatedIsochrones_Wheelchair_Override.isActive() == True: # Check if override button shall be used
                        aggregated_isochrones_wheelchair_value, irrelevantsuccessstorage = self.dlg.AggregatedIsochrones_Wheelchair_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        aggregated_isochrones_wheelchair_value = self.dlg.AggregatedIsochrones_Wheelchair.isChecked() # Receiving Value from GUI: QCheckBox
                    if aggregated_isochrones_wheelchair_value is not None: # Check if received value is NULL
                        aggregated_isochrones_wheelchair_urlstring = '&wheelchair=' + str(aggregated_isochrones_wheelchair_value) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        aggregated_isochrones_wheelchair_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    aggregated_isochrones_wheelchair_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                    
                #WaitReluctance
                if self.dlg.AggregatedIsochrones_WaitReluctance_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.AggregatedIsochrones_WaitReluctance_Override.isActive() == True: # Check if override button shall be used
                        aggregated_isochrones_waitreluctance_value, irrelevantsuccessstorage = self.dlg.AggregatedIsochrones_WaitReluctance_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        aggregated_isochrones_waitreluctance_value = self.dlg.AggregatedIsochrones_WaitReluctance.value() # Receiving Value from GUI: QDoubleSpinBox
                    if aggregated_isochrones_waitreluctance_value is not None: # Check if received value is NULL
                        aggregated_isochrones_waitreluctance_float = round(float(aggregated_isochrones_waitreluctance_value),2)
                        aggregated_isochrones_waitreluctance_urlstring = '&waitReluctance=' + str(aggregated_isochrones_waitreluctance_float) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        aggregated_isochrones_waitreluctance_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    aggregated_isochrones_waitreluctance_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                    
                #MaxTransfers
                if self.dlg.AggregatedIsochrones_MaxTransfers_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.AggregatedIsochrones_MaxTransfers_Override.isActive() == True: # Check if override button shall be used
                        aggregated_isochrones_maxtransfers_value, irrelevantsuccessstorage = self.dlg.AggregatedIsochrones_MaxTransfers_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        aggregated_isochrones_maxtransfers_value = self.dlg.AggregatedIsochrones_MaxTransfers.value() # Receiving Value from GUI: QSpinBox
                    if aggregated_isochrones_maxtransfers_value is not None: # Check if received value is NULL
                        aggregated_isochrones_maxtransfers_urlstring = '&maxTransfers=' + str(aggregated_isochrones_maxtransfers_value) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        aggregated_isochrones_maxtransfers_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    aggregated_isochrones_maxtransfers_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                 
                #MaxWalkDistance
                if self.dlg.AggregatedIsochrones_MaxWalkDistance_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.AggregatedIsochrones_MaxWalkDistance_Override.isActive() == True: # Check if override button shall be used
                        aggregated_isochrones_maxwalkdistance_value, irrelevantsuccessstorage = self.dlg.AggregatedIsochrones_MaxWalkDistance_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        aggregated_isochrones_maxwalkdistance_value = self.dlg.AggregatedIsochrones_MaxWalkDistance.value() # Receiving Value from GUI: QSpinBox
                    if aggregated_isochrones_maxwalkdistance_value is not None: # Check if received value is NULL
                        aggregated_isochrones_maxwalkdistance_urlstring = '&maxWalkDistance=' + str(aggregated_isochrones_maxwalkdistance_value) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        aggregated_isochrones_maxwalkdistance_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    aggregated_isochrones_maxwalkdistance_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                 
                #MaxOffroadDistance
                if self.dlg.AggregatedIsochrones_MaxOffroadDistance_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.AggregatedIsochrones_MaxOffroadDistance_Override.isActive() == True: # Check if override button shall be used
                        aggregated_isochrones_maxoffroaddistance_value, irrelevantsuccessstorage = self.dlg.AggregatedIsochrones_MaxOffroadDistance_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        aggregated_isochrones_maxoffroaddistance_value = self.dlg.AggregatedIsochrones_MaxOffroadDistance.value() # Receiving Value from GUI: QSpinBox
                    if aggregated_isochrones_maxoffroaddistance_value is not None: # Check if received value is NULL
                        aggregated_isochrones_maxoffroaddistance_urlstring = '&offRoadDistanceMeters=' + str(aggregated_isochrones_maxoffroaddistance_value) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        aggregated_isochrones_maxoffroaddistance_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    aggregated_isochrones_maxoffroaddistance_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                 
                #PrecisionMeters
                if self.dlg.AggregatedIsochrones_PrecisionMeters_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.AggregatedIsochrones_PrecisionMeters_Override.isActive() == True: # Check if override button shall be used
                        aggregated_isochrones_precisionmeters_value, irrelevantsuccessstorage = self.dlg.AggregatedIsochrones_PrecisionMeters_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        aggregated_isochrones_precisionmeters_value = self.dlg.AggregatedIsochrones_PrecisionMeters.value() # Receiving Value from GUI: QSpinBox
                    if aggregated_isochrones_precisionmeters_value is not None: # Check if received value is NULL
                        aggregated_isochrones_precisionmeters_urlstring = '&precisionMeters=' + str(aggregated_isochrones_precisionmeters_value) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        aggregated_isochrones_precisionmeters_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    aggregated_isochrones_precisionmeters_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)                   
    
                #Isochrones Interval
                if self.dlg.AggregatedIsochrones_Interval_Override.isActive() == True:
                    aggregated_isochrones_interval_value, irrelevantsuccessstorage = self.dlg.AggregatedIsochrones_Interval_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    aggregated_isochrones_interval_value = self.dlg.AggregatedIsochrones_Interval.toPlainText() #Receiving Value from GUI: QTextEdit
                if not aggregated_isochrones_interval_value: # Check if it is NULL
                    aggregated_isochrones_interval_value = '300,600,900' # Make sure cutoffSec is not empty because it is a must have parameter   
                aggregated_isochrones_interval_value = aggregated_isochrones_interval_value.replace(" ", "")  # Remove whitespaces in case user entered them              
                interval_list = list(aggregated_isochrones_interval_value.split(",")) # Split given Integers (as string) separated by comma into a list
                interval_list_new = []
                for entry in interval_list:
                    if entry.lower().endswith('m'):
                        entry = str(int(entry.lower().replace('m',''))*60)
                    elif entry.lower().endswith('h'):
                        entry = str(int(entry.lower().replace('h',''))*3600)
                    interval_list_new.append(entry)
                aggregated_isochrones_interval_urlstring = "&cutoffSec=".join(interval_list_new) #Join the list to a string and add leading "&cutoffSec=" to each Integer. The first item of the list will get no leading "&cutoffSec=", we will add this later
    
                #Transportation Mode
                if self.dlg.AggregatedIsochrones_TransportationMode_Override.isActive() == True:
                    aggregated_isochrones_transportationmode_value, irrelevantsuccessstorage = self.dlg.AggregatedIsochrones_TransportationMode_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    aggregated_isochrones_transportationmode_value = self.dlg.AggregatedIsochrones_TransportationMode.toPlainText() #Receiving Value from GUI: QTextEdit
                if not aggregated_isochrones_transportationmode_value: # Check if it is NULL
                    aggregated_isochrones_transportationmode_value = 'WALK,TRANSIT' # Make sure Mode is not empty because it is a must have parameter
                aggregated_isochrones_transportationmode_urlstring = "&mode=" + aggregated_isochrones_transportationmode_value.upper() # Make sure Mode is given as uppercase to prevent possible server errors (not sure how otp handels this exactly)
                
                #Additional Parameters
                if self.dlg.AggregatedIsochrones_AdditionalParameters_Override.isActive() == True:
                    aggregated_isochrones_additionalparameters_value, irrelevantsuccessstorage = self.dlg.AggregatedIsochrones_AdditionalParameters_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    aggregated_isochrones_additionalparameters_value = self.dlg.AggregatedIsochrones_AdditionalParameters.toPlainText() #Receiving Value from GUI: QTextEdit
                if aggregated_isochrones_additionalparameters_value is not None: # If Additional Parameters are filled, use it
                    aggregated_isochrones_additionalparameters_urlstring = str(aggregated_isochrones_additionalparameters_value) # Create the string
                else: # If Additional Parameters are not filled, do not use it
                    aggregated_isochrones_additionalparameters_urlstring = '' # Create the string (Empty, because it is not used, not NULL!!)
                    
                ##################################
                
                #From DateTime
                if self.dlg.AggregatedIsochrones_FromDateTime_Override.isActive() == True: # Check if override button shall be used
                    aggregated_isochrones_fromdatetime_value, irrelevantsuccessstorage = self.dlg.AggregatedIsochrones_FromDateTime_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    aggregated_isochrones_fromdatetime_value = self.dlg.AggregatedIsochrones_FromDateTime.dateTime().toString("yyyy-MM-dd HH:mm:ss") # Receiving Value from GUI: QDateTime
                aggregated_isochrones_fromdatetime_value = datetime.strptime(aggregated_isochrones_fromdatetime_value, '%Y-%m-%d %H:%M:%S')
                    
                #To DateTime
                if self.dlg.AggregatedIsochrones_ToDateTime_Override.isActive() == True: # Check if override button shall be used
                    aggregated_isochrones_todatetime_value, irrelevantsuccessstorage = self.dlg.AggregatedIsochrones_ToDateTime_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    aggregated_isochrones_todatetime_value = self.dlg.AggregatedIsochrones_ToDateTime.dateTime().toString("yyyy-MM-dd HH:mm:ss") # Receiving Value from GUI: QDateTime
                aggregated_isochrones_todatetime_value = datetime.strptime(aggregated_isochrones_todatetime_value, '%Y-%m-%d %H:%M:%S')
                
                #RequestInterval             
                if self.dlg.AggregatedIsochrones_RequestInterval_Override.isActive() == True: # Check if override button shall be used
                    aggregated_isochrones_requestinterval_value, irrelevantsuccessstorage = self.dlg.AggregatedIsochrones_RequestInterval_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    aggregated_isochrones_requestinterval_value = self.dlg.AggregatedIsochrones_RequestInterval.value() # Receiving Value from GUI: QSpinBox
                
                QgsMessageLog.logMessage('aggregated_isochrones_requestinterval_value: ' + str(aggregated_isochrones_requestinterval_value) + 
                                         " aggregated_isochrones_requestinterval_value: " + str(aggregated_isochrones_requestinterval_value) + 
                                         " aggregated_isochrones_todatetime_value: " + str(aggregated_isochrones_todatetime_value) + 
                                         " aggregated_isochrones_fromdatetime_value: " + str(aggregated_isochrones_fromdatetime_value)
                                         ,MESSAGE_CATEGORY,Qgis.Warning)
                
                #Cancel execution if....:
                if (not aggregated_isochrones_requestinterval_value or aggregated_isochrones_requestinterval_value < 1 or aggregated_isochrones_todatetime_value < aggregated_isochrones_fromdatetime_value):
                    self.aggregated_isochrones_state = 4
                    QgsMessageLog.logMessage("Warning! There is something wrong with your DateTime-Settings, check them and try again.",MESSAGE_CATEGORY,Qgis.Warning)
                    break
                
                # Iterating over the datetimes
                intervalseconds = (aggregated_isochrones_todatetime_value - aggregated_isochrones_fromdatetime_value).seconds
                intervaliteration = 0
                tmp_aggregated_isochrones_vl = None
                QgsMessageLog.logMessage('Intervalseconds: ' + str(intervalseconds) + " Requestintervalvalue: " + str(aggregated_isochrones_requestinterval_value),MESSAGE_CATEGORY,Qgis.Warning)
                for currentsecond in range(0,intervalseconds,aggregated_isochrones_requestinterval_value):
                    intervaliteration += 1
                    if self.stopaggregated_isochronesworker == True: # if cancel button has been clicked this var has been set to True to break the loop so the thread can be quit
                        self.aggregated_isochrones_state = 2
                        break
                    
                    aggregated_isochrones_currentdatetime_value = (aggregated_isochrones_fromdatetime_value + timedelta(seconds = currentsecond))
                    aggregated_isochrones_currentdatetime_string = aggregated_isochrones_currentdatetime_value.strftime("%Y-%m-%d %H:%M:%S")
                    aggregated_isochrones_currentdate_string = aggregated_isochrones_currentdatetime_value.strftime("%Y-%m-%d")
                    aggregated_isochrones_currenttime_string = aggregated_isochrones_currentdatetime_value.strftime("%H:%M:%S")
                    aggregated_isochrones_currentdate_urlstring = '&date=' + str(aggregated_isochrones_currentdate_string)
                    aggregated_isochrones_currenttime_urlstring = '&time=' + str(aggregated_isochrones_currenttime_string)
                    
                    if intervaliteration == 1: # Create temporary polygon layer we can dissolve later to get the maximum
                        tmp_aggregated_isochrones_vl = QgsVectorLayer("MultiPolygon?crs=epsg:4326", "TmpAggregatedIsochrones", "memory")
                        tmp_aggregated_isochrones_pr = tmp_aggregated_isochrones_vl.dataProvider()
                        with edit(tmp_aggregated_isochrones_vl):
                            tmp_aggregated_isochrones_pr.addAttributes([QgsField("time",QVariant.Int)])
                    
                    with edit(tmp_aggregated_isochrones_vl):
                        #Working example: https://api.digitransit.fi/routing/v1/routers/hsl/isochrone?fromPlace=60.169,24.938&mode=WALK,TRANSIT&date=2019-11-01&time=08:00:00&maxWalkDistance=500&cutoffSec=1800&cutoffSec=3600
                        #Concat URL and convert to string
                        isochrone_url = (str(serverurl) + "isochrone?algorithm=accSampling" + # Add Isochrones request and algorithm to server url
                                        "&fromPlace=" + str(y) + "," + str(x) + # concatenate x and y coordinates as string
                                        aggregated_isochrones_transportationmode_urlstring + #
                                        aggregated_isochrones_walkspeed_urlstring + #
                                        aggregated_isochrones_bikespeed_urlstring + #
                                        aggregated_isochrones_currentdate_urlstring + #
                                        aggregated_isochrones_currenttime_urlstring + #
                                        aggregated_isochrones_arriveby_urlstring + #
                                        aggregated_isochrones_wheelchair_urlstring + #
                                        aggregated_isochrones_waitreluctance_urlstring + #
                                        aggregated_isochrones_maxtransfers_urlstring + #
                                        aggregated_isochrones_maxwalkdistance_urlstring + #
                                        aggregated_isochrones_maxoffroaddistance_urlstring + #
                                        aggregated_isochrones_precisionmeters_urlstring + #
                                        aggregated_isochrones_additionalparameters_urlstring + # Additional Parameters entered as OTP-Readable string -> User responsibility
                                        "&cutoffSec=" + str(aggregated_isochrones_interval_urlstring) # Interval-Integers are taken as comma separated string, then split into list and then joined to string with leading "&cutoffSec=". The first interval therefore has no leading "&cutoffSec=" thats why we add it here
                                        )
                        QgsMessageLog.logMessage('Intervaliteration: ' + str(intervaliteration) + " of Feature ID: " + str(inputlayer_feature.id()) + ' at DateTime: ' + str(aggregated_isochrones_currentdatetime_string) + '\nwith URL: ' + str(isochrone_url),MESSAGE_CATEGORY,Qgis.Info)
                        debug_info = "Feature ID: " + str(inputlayer_feature.id()) + ' at iteration: ' + str(intervaliteration) + ' with URL: ' + str(isochrone_url) + '\n'
                        
                        #request and download file
                        isochrone_responseLayer = None
                        try:
                            isochrone_headers = {"accept":"application/x-zip-compressed"}
                            isochrone_request = urllib.request.Request(isochrone_url, headers=isochrone_headers)
                            isochrone_response = urllib.request.urlopen(isochrone_request, timeout=self.gf.timeout_setting)
                            # Sending request to server. Using shapefiles to avoid invalid geometries on high level of detail + geojson throwback seems to be limited to 4 decimals.
                        #save file
                            try:
                                with open(tmp_save_location + 'isochrones.zip', 'wb') as f: # Write shapefile to temp location
                                    f.write(isochrone_response.read())
                                    #f.write(r.content) # write zip content
                        #unzip file
                                try:
                                    with zipfile.ZipFile(tmp_save_location + 'isochrones.zip', 'r') as zip_ref:
                                        zip_ref.extractall(tmp_save_location) 
                        #load file
                                    try:
                                        isochrone_responseLayer = QgsVectorLayer(tmp_save_location + "null.shp", "null", "ogr") # load just downloaded file as vector layer
                                        isochrone_responseLayer.updateExtents()
                                    except Exception as e:
                                        isochrone_error = f'Error: loading response failed (Exception {str(e)})'
                                        isochrone_errors.append(isochrone_error)
                                except Exception as e:
                                    isochrone_error = f'Error: response file not valid (Exception {str(e)})'
                                    isochrone_errors.append(isochrone_error)
                            except Exception as e:
                                isochrone_error = f'Error: writing response to harddrive failed (Exception {str(e)})'
                                isochrone_errors.append(isochrone_error)
                        except Exception as e:
                            isochrone_error = f'Error: request failed (Exception {str(e)})' 
                            isochrone_errors.append(isochrone_error)

                        # Check Validity of Responselayer
                        try:
                            if not isochrone_responseLayer:
                                isochrone_error = 'Error: response layer does not exist'
                                isochrone_errors.append(isochrone_error)
                            elif (not isochrone_responseLayer.isValid()) or (isochrone_responseLayer.extent().yMaximum() == 0.0) or (isochrone_responseLayer.extent().xMaximum() == 0.0) or (isochrone_responseLayer.extent().yMinimum() == 0.0) or (isochrone_responseLayer.extent().xMinimum() == 0.0):
                                isochrone_error = 'Error: response layer is not valid'
                                isochrone_errors.append(isochrone_error)
                        except Exception as e:
                            isochrone_error = f'Error: response layer is not valid (Exception {str(e)})'
                            isochrone_errors.append(isochrone_error)
                        
                        # Cancel this isochrone on errors
                        if isochrone_errors:
                            continue
                        
                        #iterate trough isochrone
                        for isochrone_feature in isochrone_responseLayer.getFeatures():
                            tmp_aggregated_isochrones_pr.addFeature(isochrone_feature) # copy features of responselayer including geometry and attributes (it is always only one attribute) to new layer  
                        tmp_aggregated_isochrones_vl.updateFields()
                        tmp_aggregated_isochrones_vl.updateExtents()
                        
                        tmp_aggregated_unionprocessing = tmp_aggregated_isochrones_vl # assign to a new var so we can work with it in if and also use try except in there
                        
                        if self.dlg.AggregatedIsochrones_AllUnion_Use.isChecked():
                            try: # v.clean
                                vclean_params = {'-b' : False, 
                                                 '-c' : False, 
                                                 'GRASS_MIN_AREA_PARAMETER' : 0.0001, 
                                                 'GRASS_OUTPUT_TYPE_PARAMETER' : 0, 
                                                 'GRASS_REGION_PARAMETER' : None, 
                                                 'GRASS_SNAP_TOLERANCE_PARAMETER' : -1, 
                                                 'GRASS_VECTOR_DSCO' : '', 
                                                 'GRASS_VECTOR_EXPORT_NOCAT' : False, 
                                                 'GRASS_VECTOR_LCO' : '', 
                                                 'error' : 'TEMPORARY_OUTPUT', 
                                                 'input' : tmp_aggregated_unionprocessing, 
                                                 'output' : 'TEMPORARY_OUTPUT', 
                                                 'threshold' : '', 
                                                 'tool' : [0], 
                                                 'type' : [0,1,2,3,4,5,6] 
                                                 }
                                tmp_aggregated_unionprocessing = processing.run('grass7:v.clean',vclean_params)
                                tmp_aggregated_unionprocessing = tmp_aggregated_unionprocessing['output']
                            except Exception as e:
                                isochrone_error = f'Error: Execution of v.clean failed (Exception {str(e)})'
                                isochrone_errors.append(isochrone_error)
                                
                            try: # fix geometries
                                fixgeometries_params = {'INPUT' : tmp_aggregated_unionprocessing, 
                                                        'OUTPUT' : 'TEMPORARY_OUTPUT' 
                                                       }
                                tmp_aggregated_unionprocessing = processing.run('native:fixgeometries',fixgeometries_params)
                                tmp_aggregated_unionprocessing = tmp_aggregated_unionprocessing['OUTPUT']
                            except Exception as e:
                                isochrone_error = f'Error: Execution of Fix Geometries failed (Exception {str(e)})'
                                isochrone_errors.append(isochrone_error)
                                
                            try: # union
                                union_params = {'INPUT' : tmp_aggregated_unionprocessing, 
                                                'OUTPUT' : 'TEMPORARY_OUTPUT', 
                                                'OVERLAY' : None, 
                                                'OVERLAY_FIELDS_PREFIX' : '' 
                                               }
                                tmp_aggregated_unionprocessing = processing.run('native:union',union_params)
                                tmp_aggregated_unionprocessing = tmp_aggregated_unionprocessing['OUTPUT']
                            except Exception as e:
                                isochrone_error = f'Error: Execution of Union failed (Exception {str(e)})'
                                isochrone_errors.append(isochrone_error)
                                # Continue if Union fails, that makes no sense anymore...
                                continue
                                
                            try: # aggregated
                                aggregate_params = {'AGGREGATES' : [{'aggregate': 'minimum',
                                                                     'delimiter': ',',
                                                                     'input': '"time"',
                                                                     'length': 0,
                                                                     'name': 'time',
                                                                     'precision': 0,
                                                                     'type': 2
                                                                    }], 
                                                    'GROUP_BY' : '$geometry', 
                                                    'INPUT' : tmp_aggregated_unionprocessing, 
                                                    'OUTPUT' : 'TEMPORARY_OUTPUT' 
                                                   }
                                tmp_aggregated_unionprocessing = processing.run('native:aggregate',aggregate_params)
                                tmp_aggregated_unionprocessing = tmp_aggregated_unionprocessing['OUTPUT']
                            except Exception as e:
                                isochrone_error = f'Error: Execution of Aggregate failed (Exception {str(e)})'
                                isochrone_errors.append(isochrone_error)
                                # Continue if Aggregate fails, that makes no sense anymore...
                                continue
                                
                        # End of If Union
                        
                    # END OF EDIT TEMP LAYER
                
                # END OF TIME ITERATION
                
                tmp_aggregated_dissolveprocessing = tmp_aggregated_isochrones_vl
                tmp_aggregated_rawnoaggprocessing = tmp_aggregated_isochrones_vl
                
                if self.dlg.AggregatedIsochrones_MaxDissolve_Use.isChecked(): # Dissolve the temp-layer
                    try: # dissolve
                        dissolve_params = {'FIELD':['time'], 
                                           'INPUT':tmp_aggregated_isochrones_vl, 
                                           'OUTPUT':'TEMPORARY_OUTPUT'
                                          }
                        dissolve_tmplayer = processing.run("native:dissolve", )
                        tmp_aggregated_isochrones_vl = dissolve_tmplayer['OUTPUT']
                    except Exception as e:
                        aggregated_isochrone_error = f'Error: Execution of Dissolve failed (Exception {str(e)})'
                        aggregated_isochrone_errors.append(aggregated_isochrone_error)
                        
                if self.dlg.AggregatedIsochrones_AllUnion_Use.isChecked():
                    try: # v.clean
                        vclean_params = {'-b' : False, 
                                         '-c' : False, 
                                         'GRASS_MIN_AREA_PARAMETER' : 0.0001, 
                                         'GRASS_OUTPUT_TYPE_PARAMETER' : 0, 
                                         'GRASS_REGION_PARAMETER' : None, 
                                         'GRASS_SNAP_TOLERANCE_PARAMETER' : -1, 
                                         'GRASS_VECTOR_DSCO' : '', 
                                         'GRASS_VECTOR_EXPORT_NOCAT' : False, 
                                         'GRASS_VECTOR_LCO' : '', 
                                         'error' : 'TEMPORARY_OUTPUT', 
                                         'input' : tmp_aggregated_unionprocessing, 
                                         'output' : 'TEMPORARY_OUTPUT', 
                                         'threshold' : '', 
                                         'tool' : [0], 
                                         'type' : [0,1,2,3,4,5,6] 
                                         }
                        tmp_aggregated_unionprocessing = processing.run('grass7:v.clean',vclean_params)
                        tmp_aggregated_unionprocessing = tmp_aggregated_unionprocessing['output']
                    except Exception as e:
                        aggregated_isochrone_error = f'Error: Execution of v.clean failed (Exception {str(e)})'
                        aggregated_isochrone_errors.append(aggregated_isochrone_error)
                        
                    try: # fix geometries
                        fixgeometries_params = {'INPUT' : tmp_aggregated_unionprocessing, 
                                                'OUTPUT' : 'TEMPORARY_OUTPUT' 
                                               }
                        tmp_aggregated_unionprocessing = processing.run('native:fixgeometries',fixgeometries_params)
                        tmp_aggregated_unionprocessing = tmp_aggregated_unionprocessing['OUTPUT']
                    except Exception as e:
                        aggregated_isochrone_error = f'Error: Execution of Fix Geometries failed (Exception {str(e)})'
                        aggregated_isochrone_errors.append(aggregated_isochrone_error)
                        
                    try: # union
                        union_params = {'INPUT' : tmp_aggregated_unionprocessing, 
                                        'OUTPUT' : 'TEMPORARY_OUTPUT', 
                                        'OVERLAY' : None, 
                                        'OVERLAY_FIELDS_PREFIX' : '' 
                                       }
                        tmp_aggregated_unionprocessing = processing.run('native:union',union_params)
                        tmp_aggregated_unionprocessing = tmp_aggregated_unionprocessing['OUTPUT']
                    except Exception as e:
                        aggregated_isochrone_error = f'Error: Execution of Union failed (Exception {str(e)})'
                        aggregated_isochrone_errors.append(aggregated_isochrone_error)
                        
                    try: # points on surface
                        pointonsurface_params = {'ALL_PARTS' : True, 
                                                 'INPUT' : tmp_aggregated_unionprocessing, 
                                                 'OUTPUT' : 'TEMPORARY_OUTPUT' 
                                                }
                        tmp_pointonsurface = processing.run('native:pointonsurface',pointonsurface_params)
                        tmp_pointonsurface = tmp_pointonsurface['OUTPUT']
                        createspatialindex_params = {'INPUT' : tmp_pointonsurface}
                        tmp_pointonsurface = processing.run('native:createspatialindex',createspatialindex_params)
                        tmp_pointonsurface = tmp_pointonsurface['OUTPUT']
                    except Exception as e:
                        aggregated_isochrone_error = f'Error: Execution of Point On Surface / Create Spatial Index failed (Exception {str(e)})'
                        aggregated_isochrone_errors.append(aggregated_isochrone_error)
                        
                    try: # join by location summary
                        joinbylocationsummary_params = {'DISCARD_NONMATCHING' : False, 
                                                        'INPUT' : tmp_aggregated_unionprocessing, 
                                                        'JOIN' : tmp_pointonsurface, 
                                                        'JOIN_FIELDS' : ['time'], 
                                                        'OUTPUT' : 'TEMPORARY_OUTPUT', 
                                                        'PREDICATE' : [1], 
                                                        'SUMMARIES' : [] 
                                                       }
                        tmp_aggregated_unionprocessing = processing.run('qgis:joinbylocationsummary',joinbylocationsummary_params)
                        tmp_aggregated_unionprocessing = tmp_aggregated_unionprocessing['OUTPUT']
                    except Exception as e:
                        aggregated_isochrone_error = f'Error: Execution of Join By Location Summary failed (Exception {str(e)})'
                        aggregated_isochrone_errors.append(aggregated_isochrone_error)
                        
                # End of If Union
                
                # assign different layers back to only one var
                if self.dlg.AggregatedIsochrones_MaxDissolve_Use.isChecked():
                    tmp_aggregated_isochrones_vl = tmp_aggregated_dissolveprocessing
                elif self.dlg.AggregatedIsochrones_AllUnion_Use.isChecked():
                    tmp_aggregated_isochrones_vl = tmp_aggregated_unionprocessing
                elif self.dlg.AggregatedIsochrones_NoAggRaw_Use.isChecked():
                    tmp_aggregated_isochrones_vl = tmp_aggregated_rawnoaggprocessing
                else: 
                    tmp_aggregated_isochrones_vl = tmp_aggregated_rawnoaggprocessing
                
                
                # Throw back final status on this one
                if aggregated_isochrone_errors:
                    aggregated_isochrone_unique_errors = set(aggregated_isochrone_errors)
                    aggregated_isochrone_unique_errors = list(aggregated_isochrone_unique_errors)
                    unique_errors.extend(aggregated_isochrone_unique_errors)
                    QgsMessageLog.logMessage('Isochrone Errors: ' + str("; ".join(aggregated_isochrone_unique_errors)),MESSAGE_CATEGORY,Qgis.Warning)
                    
                # Check Validity
                try:
                    if not tmp_aggregated_isochrones_vl:
                        tmp_aggregated_isochrones_error = 'Error: aggregated layer does not exist'
                        tmp_aggregated_isochrones_errors.append(tmp_aggregated_isochrones_error)
                    elif (not tmp_aggregated_isochrones_vl.isValid()) or (tmp_aggregated_isochrones_vl.extent().yMaximum() == 0.0) or (tmp_aggregated_isochrones_vl.extent().xMaximum() == 0.0) or (tmp_aggregated_isochrones_vl.extent().yMinimum() == 0.0) or (tmp_aggregated_isochrones_vl.extent().xMinimum() == 0.0):
                        tmp_aggregated_isochrones_error = 'Error: aggregated layer is not valid'
                        tmp_aggregated_isochrones_errors.append(tmp_aggregated_isochrones_error)
                except Exception as e:
                    tmp_aggregated_isochrones_error = f'Error: aggregated layer is not valid (Exception {str(e)})'
                    tmp_aggregated_isochrones_errors.append(tmp_aggregated_isochrones_error)
                
                # Create Dummylayer on Error to prevent errors in code or broken result layer
                if tmp_aggregated_isochrones_errors:
                    tmp_aggregated_isochrones_vl = QgsVectorLayer("MultiPolygon?crs=epsg:4326","Errorlayer","memory")
                    tmp_aggregated_isochrones_vl_pr = tmp_aggregated_isochrones_vl.dataProvider()
                    tmp_aggregated_isochrones_vl.startEditing()
                    error_feature = QgsFeature()
                    error_feature.setGeometry(QgsGeometry.fromWkt("Polygon ((-0.1 -0.1, -0.1 0.1, 0.1 0.1, 0.1 -0.1, -0.1 -0.1))"))
                    tmp_aggregated_isochrones_vl_pr.addAttributes([QgsField("time",QVariant.Int)])
                    for j in interval_list:
                        tmp_aggregated_isochrones_vl_pr.addFeatures([error_feature])
                    tmp_aggregated_isochrones_vl.commitChanges()
                    tmp_aggregated_isochrones_vl.updateExtents()
                    
                inputfeature_base_url_without_datetime = isochrone_url # remove &date=...&time=... for the url in attributes, everything else is valid on inputfeature base
                
                #iterate trough isochrones
                aggregated_isochrone_id_counter = aggregated_isochrone_id_counter + 1
                
                for aggregated_isochrone_feature in tmp_aggregated_isochrones_vl.getFeatures():
                    aggregated_isochrone_uid_counter = aggregated_isochrone_uid_counter + 1
                    aggregated_isochrones_memorylayer_pr.addFeature(aggregated_isochrone_feature) # copy features of response including geometry and attributes to new layer  
                    attrs_aggregated_isochrone = { 1 : aggregated_isochrone_uid_counter,
                                                   2 : aggregated_isochrone_id_counter,
                                                   3 : str("; ".join(aggregated_isochrone_unique_errors)) if aggregated_isochrone_errors else None,
                                                   4 : aggregated_isochrone_url } # set further generic attributes
                    aggregated_isochrones_memorylayer_pr.changeAttributeValues({ aggregated_isochrone_feature.id() : attrs_aggregated_isochrone }) # change attribute values of new layer to the just set ones  
                    for i in range(0, inputlayer_numberoffields): # iterate over new layer as many fields as the input layer has                
                        attrs_inputlayer = { i + 5 : Inputlayer_Attributes[i] } # set attributes of inputlayer (+5 because we added 5 new fields before)
                        aggregated_isochrones_memorylayer_pr.changeAttributeValues({ aggregated_isochrone_feature.id() : attrs_inputlayer }) # change attribute values of new layer to the ones from inputlayer 
                        if aggregated_isochrone_error: # change stuff to null/dummy if isochrone is not valid
                            err_attrs_aggregated_isochrone = { 0 : 0 } # set time field to 0 on error
                            aggregated_isochrones_memorylayer_pr.changeAttributeValues({ aggregated_isochrone_feature.id() : err_attrs_aggregated_isochrone }) # set time field to 0 on error
                            nullgeom = QgsGeometry.fromWkt("Polygon ((-0.1 -0.1, -0.1 0.1, 0.1 0.1, 0.1 -0.1, -0.1 -0.1))") # create pseudopolygon
                            #nullgeom = QgsGeometry.fromWkt('') #causes issues with layer. Just stick to pseudopolygon
                            aggregated_isochrones_memorylayer_pr.changeGeometryValues({ aggregated_isochrone_feature.id() : nullgeom }) # set geometry of feature to null on error 

                aggregated_isochrones_memorylayer_vl.updateFields()
                aggregated_isochrones_memorylayer_vl.updateExtents()
                
                # Update Progressbar
                progressbar_percent = progressbar_counter / float(progressbar_featurecount) * 100
                self.aggregated_isochrones_progress.emit(int(progressbar_percent))
                
                QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info)
                QgsMessageLog.logMessage("-----",MESSAGE_CATEGORY,Qgis.Info)
                QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info)
                
            #END OF INPUTLAYER FEATURE LOOP
            
            # Isochrones Memory VectorLayer
            aggregated_isochrones_memorylayer_vl.updateFields()
            aggregated_isochrones_memorylayer_vl.updateExtents()

        unique_errors = set(unique_errors)
        unique_errors = list(unique_errors)
        unique_errors = '; '.join(unique_errors)
        aggregated_isochrones_endtime = datetime.now()
        aggregated_isochrones_runtime = aggregated_isochrones_endtime - aggregated_isochrones_starttime
        if self.stopaggregated_isochronesworker == True:
            QgsMessageLog.logMessage("##### Max-Isochrones job canceled by user after " + str(aggregated_isochrones_runtime) + " @ " + str(datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")) + " #####",MESSAGE_CATEGORY,Qgis.Info)
        else:
            QgsMessageLog.logMessage("##### Max-Isochrones job done in " + str(aggregated_isochrones_runtime) + " @ " + str(datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")) + " #####",MESSAGE_CATEGORY,Qgis.Info)
        QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info)

        self.aggregated_isochrones_finished.emit(aggregated_isochrones_memorylayer_vl, self.aggregated_isochrones_state, str(unique_errors), str(aggregated_isochrones_runtime))
