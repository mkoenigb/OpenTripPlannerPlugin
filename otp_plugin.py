# -*- coding: utf-8 -*-
"""
/***************************************************************************
 OpenTripPlannerPlugin
                                 A QGIS plugin
 This plugin makes OpenTripPlanner functionalities accessible in QGIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-10-21
        git sha              : $Format:%H$
        copyright            : (C) 2019 - Today by Mario KÃ¶nigbauer
        email                : mkoenigb@gmx.de
        repository           : https://github.com/mkoenigb/OpenTripPlannerPlugin
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, qVersion, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog
from PyQt5.QtNetwork import  QNetworkAccessManager, QNetworkRequest
from PyQt5.QtCore import *
from qgis.core import *
from qgis.utils import *


# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .otp_plugin_dialog import OpenTripPlannerPluginDialog
from osgeo import ogr
from datetime import *
import os.path
import os
import urllib.request
import urllib
import zipfile
import json

MESSAGE_CATEGORY = 'OpenTripPlanner PlugIn'

class OpenTripPlannerPlugin(): #OpenTripPlannerPlugin(QgsTask):
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        #super(OpenTripPlannerPlugin, self).__init__() # related to QgsTask Test - https://stackoverflow.com/a/12280579
        
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'OpenTripPlannerPlugin_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&OpenTripPlanner Plugin')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('OpenTripPlannerPlugin', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/otp_plugin/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'OpenTripPlanner Plugin'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&OpenTripPlanner Plugin'),
                action)
            self.iface.removeToolBarIcon(action)
 
    # https://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/settings.html and https://gis.stackexchange.com/questions/114527/qgis-plugin-with-save-settings-dialog
    def store_general_variables(self):
        s = QgsSettings()
        self.serverurl = self.dlg.GeneralSettings_ServerURL.toPlainText() # read from textbox
        s.setValue("otp_plugin/GeneralSettings_ServerURL", self.serverurl) # store as variable via QgsSettings
        self.iface.messageBar().pushMessage("Success", "General settings stored! ServerURL: " + self.serverurl, MESSAGE_CATEGORY, level=Qgis.Success, duration=3)
        QgsMessageLog.logMessage("General settings stored! ServerURL: " + self.serverurl,MESSAGE_CATEGORY,Qgis.Info)
        
    def read_general_variables(self):
        s = QgsSettings()
        #ServerURL = s.value("myplugin/mytext", "http://localhost:8080/otp/routers/test/")
        self.serverurl = s.value("otp_plugin/GeneralSettings_ServerURL", "") # read from variable via QgsSettings
        if isinstance(self.serverurl, str): self.dlg.GeneralSettings_ServerURL.setText(self.serverurl) # set textbox text to variable from QgsSettings
        #self.iface.messageBar().pushMessage("Success", "Function read_general_variables running! Var: " + self.serverurl, level=Qgis.Success, duration=3)

    def store_route_variables(self):
        s = QgsSettings()
        
        # Walk Speed
        self.routes_walkspeed_use_setting = int(self.dlg.Routes_WalkSpeed_Use.isChecked())
        s.setValue("otp_plugin/Routes_WalkSpeed_Use", self.routes_walkspeed_use_setting)
        self.routes_walkspeed_setting = float(self.dlg.Routes_WalkSpeed.value())
        s.setValue("otp_plugin/Routes_WalkSpeed", self.routes_walkspeed_setting)
        # Test for Override Buttons - doesnt work
        #self.Routes_Routes_WalkSpeed_Override_Use_setting = int(self.dlg.Routes_WalkSpeed_Override.isActive())
        #s.setValue("otp_plugin/Routes_WalkSpeed_Override_Use", self.Routes_WalkSpeed_Override_Use_setting)
        #self.Routes_Routes_WalkSpeed_Override_setting = self.dlg.Routes_WalkSpeed_Override.toProperty()
        #s.setValue("otp_plugin/Routes_WalkSpeed_Override", self.Routes_WalkSpeed_Override_setting)
        
        # Bike Speed
        self.routes_bikespeed_use_setting = int(self.dlg.Routes_BikeSpeed_Use.isChecked())
        s.setValue("otp_plugin/Routes_BikeSpeed_Use", self.routes_bikespeed_use_setting)
        self.routes_bikespeed_setting = float(self.dlg.Routes_BikeSpeed.value())
        s.setValue("otp_plugin/Routes_BikeSpeed", self.routes_bikespeed_setting)
        
        # Date
        self.routes_date_use_setting = int(self.dlg.Routes_Date_Use.isChecked())
        s.setValue("otp_plugin/Routes_Date_Use", self.routes_date_use_setting)
        self.routes_date_setting = self.dlg.Routes_Date.date()
        s.setValue("otp_plugin/Routes_Date", self.routes_date_setting)
        
        # Time
        self.routes_time_use_setting = int(self.dlg.Routes_Time_Use.isChecked())
        s.setValue("otp_plugin/Routes_Time_Use", self.routes_time_use_setting)
        self.routes_time_setting = self.dlg.Routes_Time.time()
        s.setValue("otp_plugin/Routes_Time", self.routes_time_setting)
        
        # ArriveBy
        self.routes_arriveby_use_setting = int(self.dlg.Routes_ArriveBy_Use.isChecked())
        s.setValue("otp_plugin/Routes_ArriveBy_Use", self.routes_arriveby_use_setting)
        self.routes_arriveby_setting = int(self.dlg.Routes_ArriveBy.isChecked())
        s.setValue("otp_plugin/Routes_ArriveBy", self.routes_arriveby_setting)
        
        # Wheelchair
        self.routes_wheelchair_use_setting = int(self.dlg.Routes_Wheelchair_Use.isChecked())
        s.setValue("otp_plugin/Routes_Wheelchair_Use", self.routes_wheelchair_use_setting)
        self.routes_wheelchair_setting = int(self.dlg.Routes_Wheelchair.isChecked())
        s.setValue("otp_plugin/Routes_Wheelchair", self.routes_wheelchair_setting)
        
        # Wait Reluctance
        self.routes_waitreluctance_use_setting = int(self.dlg.Routes_WaitReluctance_Use.isChecked())
        s.setValue("otp_plugin/Routes_WaitReluctance_Use", self.routes_waitreluctance_use_setting)
        self.routes_waitreluctance_setting = float(self.dlg.Routes_WaitReluctance.value())
        s.setValue("otp_plugin/Routes_WaitReluctance", self.routes_waitreluctance_setting)
        
        # Max Transfers
        self.routes_maxtransfers_use_setting = int(self.dlg.Routes_MaxTransfers_Use.isChecked())
        s.setValue("otp_plugin/Routes_MaxTransfers_Use", self.routes_maxtransfers_use_setting)
        self.routes_maxtransfers_setting = int(self.dlg.Routes_MaxTransfers.value())
        s.setValue("otp_plugin/Routes_MaxTransfers", self.routes_maxtransfers_setting)
        
        # Max Walkdistance
        self.routes_maxwalkdistance_use_setting = int(self.dlg.Routes_MaxWalkDistance_Use.isChecked())
        s.setValue("otp_plugin/Routes_MaxWalkDistance_Use", self.routes_maxwalkdistance_use_setting)
        self.routes_maxwalkdistance_setting = int(self.dlg.Routes_MaxWalkDistance.value())
        s.setValue("otp_plugin/Routes_MaxWalkDistance", self.routes_maxwalkdistance_setting)
        
        # Max Offroaddistance
        self.routes_maxoffroaddistance_use_setting = int(self.dlg.Routes_MaxOffroadDistance_Use.isChecked())
        s.setValue("otp_plugin/Routes_MaxOffroadDistance_Use", self.routes_maxoffroaddistance_use_setting)
        self.routes_maxoffroaddistance_setting = int(self.dlg.Routes_MaxOffroadDistance.value())
        s.setValue("otp_plugin/Routes_MaxOffroadDistance", self.routes_maxoffroaddistance_setting)
        
        # Iterinaries
        self.routes_iterinaries_use_setting = int(self.dlg.Routes_Iterinaries_Use.isChecked())
        s.setValue("otp_plugin/Routes_Iterinaries_Use", self.routes_iterinaries_use_setting)
        self.routes_iterinaries_setting = int(self.dlg.Routes_Iterinaries.value())
        s.setValue("otp_plugin/Routes_Iterinaries", self.routes_iterinaries_setting)        
        
        # Optimize
        self.routes_optimize_use_setting = int(self.dlg.Routes_Optimize_Use.isChecked())
        s.setValue("otp_plugin/Routes_Optimize_Use", self.routes_optimize_use_setting)
        self.routes_optimize_setting = str(self.dlg.Routes_Optimize.currentText())
        s.setValue("otp_plugin/Routes_Optimize", self.routes_optimize_setting)

        # Mode
        self.routes_transportationmode_setting = self.dlg.Routes_TransportationMode.toPlainText()
        s.setValue("otp_plugin/Routes_TransportationMode", self.routes_transportationmode_setting)
        
        # Additional Parameters
        self.routes_additionalparameters_setting = self.dlg.Routes_AdditionalParameters.toPlainText()
        s.setValue("otp_plugin/Routes_AdditionalParameters", self.routes_additionalparameters_setting)
        
        # Matrixmatching
        self.routes_onlymatching_setting = int(self.dlg.Routes_OnlyMatching.isChecked())
        s.setValue("otp_plugin/Routes_OnlyMatching", self.routes_onlymatching_setting)
        
        self.iface.messageBar().pushMessage("Success", "Route settings stored!", MESSAGE_CATEGORY, level=Qgis.Success, duration=3) 
        QgsMessageLog.logMessage("Route settings stored!",MESSAGE_CATEGORY,Qgis.Info)
        
    def read_route_variables(self):
        s = QgsSettings()
        
        # Walk Speed
        self.routes_walkspeed_use_setting = int(s.value("otp_plugin/Routes_WalkSpeed_Use", 0))
        self.dlg.Routes_WalkSpeed_Use.setChecked(self.routes_walkspeed_use_setting)
        self.routes_walkspeed_setting = float(s.value("otp_plugin/Routes_WalkSpeed", 4.828032))
        self.dlg.Routes_WalkSpeed.setValue(self.routes_walkspeed_setting)
        # Test for Override Buttons - doesnt work
        #self.Routes_WalkSpeed_Override_Use_setting = int(s.value("otp_plugin/Routes_WalkSpeed_Override_Use", 1))
        #self.dlg.Routes_WalkSpeed_Override.setActive(self.Routes_WalkSpeed_Override_Use_setting)
        #self.Routes_WalkSpeed_Override_setting = s.value("otp_plugin/Routes_WalkSpeed_Override", 4.828032)
        #self.dlg.Routes_WalkSpeed_Override.setExpressionString(self.Routes_WalkSpeed_Override_setting)
              
        # Bike Speed
        self.routes_bikespeed_use_setting = int(s.value("otp_plugin/Routes_BikeSpeed_Use", 0))
        self.dlg.Routes_BikeSpeed_Use.setChecked(self.routes_bikespeed_use_setting)
        self.routes_bikespeed_setting = float(s.value("otp_plugin/Routes_BikeSpeed", 17.7))
        self.dlg.Routes_BikeSpeed.setValue(self.routes_bikespeed_setting)
        
        # Date
        self.routes_date_use_setting = int(s.value("otp_plugin/Routes_Date_Use", 1))
        self.dlg.Routes_Date_Use.setChecked(self.routes_date_use_setting)
        self.routes_date_setting = s.value("otp_plugin/Routes_Date", QtCore.QDateTime.currentDateTime())
        # I guess nobody understands this date 'stuff'....
        try:
            self.dlg.Routes_Date.setDateTime(self.routes_date_setting) # Standard value
        except:
            self.dlg.Routes_Date.setDate(self.routes_date_setting) # Stored value
        
        # Time
        self.routes_time_use_setting = int(s.value("otp_plugin/Routes_Time_Use", 1))
        self.dlg.Routes_Time_Use.setChecked(self.routes_time_use_setting)
        self.routes_time_setting = s.value("otp_plugin/Routes_Time", QTime.fromString('14:00:00'))
        self.dlg.Routes_Time.setTime(self.routes_time_setting)
        
        # Arrive By
        self.routes_arriveby_use_setting = int(s.value("otp_plugin/Routes_ArriveBy_Use", 0))
        self.dlg.Routes_ArriveBy_Use.setChecked(self.routes_arriveby_use_setting)
        self.routes_arriveby_setting = int(s.value("otp_plugin/Routes_ArriveBy", 0))
        self.dlg.Routes_ArriveBy.setChecked(self.routes_arriveby_setting)
        
        # Wheelchair
        self.routes_wheelchair_use_setting = int(s.value("otp_plugin/Routes_Wheelchair_Use", 0))
        self.dlg.Routes_Wheelchair_Use.setChecked(self.routes_wheelchair_use_setting)
        self.routes_wheelchair_setting = int(s.value("otp_plugin/Routes_Wheelchair", 0))
        self.dlg.Routes_Wheelchair.setChecked(self.routes_wheelchair_setting)
        
        # Wait Reluctance
        self.routes_waitreluctance_use_setting = int(s.value("otp_plugin/Routes_WaitReluctance_Use", 0))
        self.dlg.Routes_WaitReluctance_Use.setChecked(self.routes_waitreluctance_use_setting)
        self.routes_waitreluctance_setting = float(s.value("otp_plugin/Routes_WaitReluctance", 0.95))
        self.dlg.Routes_WaitReluctance.setValue(self.routes_waitreluctance_setting)
        
        # Max Transfers
        self.routes_maxtransfers_use_setting = int(s.value("otp_plugin/Routes_MaxTransfers_Use", 0))
        self.dlg.Routes_MaxTransfers_Use.setChecked(self.routes_maxtransfers_use_setting)
        self.routes_maxtransfers_setting = int(s.value("otp_plugin/Routes_MaxTransfers", 5))
        self.dlg.Routes_MaxTransfers.setValue(self.routes_maxtransfers_setting)
        
        # Max WalkDistance
        self.routes_maxwalkdistance_use_setting = int(s.value("otp_plugin/Routes_MaxWalkDistance_Use", 0))
        self.dlg.Routes_MaxWalkDistance_Use.setChecked(self.routes_maxwalkdistance_use_setting)
        self.routes_maxwalkdistance_setting = int(s.value("otp_plugin/Routes_MaxWalkDistance", 1000))
        self.dlg.Routes_MaxWalkDistance.setValue(self.routes_maxwalkdistance_setting)
        
        # Max OffRoadDistance
        self.routes_maxoffroaddistance_use_setting = int(s.value("otp_plugin/Routes_MaxOffroadDistance_Use", 0))
        self.dlg.Routes_MaxOffroadDistance_Use.setChecked(self.routes_maxoffroaddistance_use_setting)
        self.routes_maxoffroaddistance_setting = int(s.value("otp_plugin/Routes_MaxOffroadDistance", 150))
        self.dlg.Routes_MaxOffroadDistance.setValue(self.routes_maxoffroaddistance_setting)
        
        # Iterinaries
        self.routes_iterinaries_use_setting = int(s.value("otp_plugin/Routes_Iterinaries_Use", 1))
        self.dlg.Routes_Iterinaries_Use.setChecked(self.routes_iterinaries_use_setting)
        self.routes_iterinaries_setting = int(s.value("otp_plugin/Routes_Iterinaries", 1))
        self.dlg.Routes_Iterinaries.setValue(self.routes_iterinaries_setting)        
        
        # Optimize
        self.routes_optimize_use_setting = int(s.value("otp_plugin/Routes_Optimize_Use", 0))
        self.dlg.Routes_Optimize_Use.setChecked(self.routes_optimize_use_setting)
        self.routes_optimize_setting = str(s.value("otp_plugin/Routes_Optimize", 'QUICK'))
        self.dlg.Routes_Optimize.setCurrentText(self.routes_optimize_setting)
        
        # Mode
        self.routes_transportationmode = s.value("otp_plugin/Routes_TransportationMode", "WALK,TRANSIT")
        if isinstance(self.routes_transportationmode, str): self.dlg.Routes_TransportationMode.setText(self.routes_transportationmode)
        
        # Additional Parameters
        self.routes_additionalparameters = s.value("otp_plugin/Routes_AdditionalParameters", "")
        if isinstance(self.routes_additionalparameters, str): self.dlg.Routes_AdditionalParameters.setText(self.routes_additionalparameters)
        
        # Matrixmatching
        self.routes_onlymatching_setting = int(s.value("otp_plugin/Routes_OnlyMatching", 1))
        self.dlg.Routes_OnlyMatching.setChecked(self.routes_onlymatching_setting)
        
        #self.iface.messageBar().pushMessage("Success", "Function read_route_variables running!", level=Qgis.Success, duration=3)

    def restore_route_variables(self):
        s = QgsSettings()
        #DefaultSettings
        # Walk Speed
        self.routes_walkspeed_use_setting = int(0)
        self.dlg.Routes_WalkSpeed_Use.setChecked(self.routes_walkspeed_use_setting)
        self.routes_walkspeed_setting = float(4.828032)
        self.dlg.Routes_WalkSpeed.setValue(self.routes_walkspeed_setting)
        
        # Bike Speed
        self.routes_bikespeed_use_setting = int(0)
        self.dlg.Routes_BikeSpeed_Use.setChecked(self.routes_bikespeed_use_setting)
        self.routes_bikespeed_setting = float(17.7)
        self.dlg.Routes_BikeSpeed.setValue(self.routes_bikespeed_setting)
        
        # Date #####
        self.routes_date_use_setting = int(1)
        self.dlg.Routes_Date_Use.setChecked(self.routes_date_use_setting)
        self.routes_date_setting = QDateTime(QtCore.QDateTime.currentDateTime())
        self.dlg.Routes_Date.setDateTime(self.routes_date_setting)
        
        # Time
        self.routes_time_use_setting = int(1)
        self.dlg.Routes_Time_Use.setChecked(self.routes_time_use_setting)
        self.routes_time_setting = QTime.fromString('14:00:00')
        self.dlg.Routes_Time.setTime(self.routes_time_setting)
        
        # Arrive By
        self.routes_arriveby_use_setting = int(0)
        self.dlg.Routes_ArriveBy_Use.setChecked(self.routes_arriveby_use_setting)
        self.routes_arriveby_setting = int(0)
        self.dlg.Routes_ArriveBy.setChecked(self.routes_arriveby_setting)
        
        # Wheelchair
        self.routes_wheelchair_use_setting = int(0)
        self.dlg.Routes_Wheelchair_Use.setChecked(self.routes_wheelchair_use_setting)
        self.routes_wheelchair_setting = int(0)
        self.dlg.Routes_Wheelchair.setChecked(self.routes_wheelchair_setting)
        
        # Wait Reluctance
        self.routes_waitreluctance_use_setting = int(0)
        self.dlg.Routes_WaitReluctance_Use.setChecked(self.routes_waitreluctance_use_setting)
        self.routes_waitreluctance_setting = float(0.95)
        self.dlg.Routes_WaitReluctance.setValue(self.routes_waitreluctance_setting)
        
        # Max Transfers
        self.routes_maxtransfers_use_setting = int(0)
        self.dlg.Routes_MaxTransfers_Use.setChecked(self.routes_maxtransfers_use_setting)
        self.routes_maxtransfers_setting = int(5)
        self.dlg.Routes_MaxTransfers.setValue(self.routes_maxtransfers_setting)
        
        # Max WalkDistance
        self.routes_maxwalkdistance_use_setting = int(0)
        self.dlg.Routes_MaxWalkDistance_Use.setChecked(self.routes_maxwalkdistance_use_setting)
        self.routes_maxwalkdistance_setting = int(1000)
        self.dlg.Routes_MaxWalkDistance.setValue(self.routes_maxwalkdistance_setting)
        
        # Max OffRoadDistance
        self.routes_maxoffroaddistance_use_setting = int(0)
        self.dlg.Routes_MaxOffroadDistance_Use.setChecked(self.routes_maxoffroaddistance_use_setting)
        self.routes_maxoffroaddistance_setting = int(150)
        self.dlg.Routes_MaxOffroadDistance.setValue(self.routes_maxoffroaddistance_setting)
        
        # Iterinaries
        self.routes_iterinaries_use_setting = int(1)
        self.dlg.Routes_Iterinaries_Use.setChecked(self.routes_iterinaries_use_setting)
        self.routes_iterinaries_setting = int(1)
        self.dlg.Routes_Iterinaries.setValue(self.routes_iterinaries_setting)        
        
        # Optimize
        self.routes_optimize_use_setting = int(0)
        self.dlg.Routes_Optimize_Use.setChecked(self.routes_optimize_use_setting)
        self.routes_optimize_setting = 'QUICK'
        self.dlg.Routes_Optimize.setCurrentText(self.routes_optimize_setting)        
        
        # Mode
        self.routes_transportationmode = ""
        if isinstance(self.routes_transportationmode, str): self.dlg.Routes_TransportationMode.setText(self.routes_transportationmode)
        
        # Additional Parameters
        self.routes_additionalparameters = ""
        if isinstance(self.routes_additionalparameters, str): self.dlg.Routes_AdditionalParameters.setText(self.routes_additionalparameters)
        
        # Matrixmatching
        self.routes_onlymatching_setting = int(1)
        self.dlg.Routes_OnlyMatching.setChecked(self.routes_onlymatching_setting)        
        
        self.iface.messageBar().pushMessage("Success", "Default route settings restored!", MESSAGE_CATEGORY, level=Qgis.Success, duration=3)
        QgsMessageLog.logMessage("Default route settings restored!",MESSAGE_CATEGORY,Qgis.Info)
        
    def store_isochrone_variables(self):
        s = QgsSettings()
        
        # Walk Speed
        self.isochrones_walkspeed_use_setting = int(self.dlg.Isochrones_WalkSpeed_Use.isChecked())
        s.setValue("otp_plugin/Isochrones_WalkSpeed_Use", self.isochrones_walkspeed_use_setting)
        self.isochrones_walkspeed_setting = float(self.dlg.Isochrones_WalkSpeed.value())
        s.setValue("otp_plugin/Isochrones_WalkSpeed", self.isochrones_walkspeed_setting)
        
        # Bike Speed
        self.isochrones_bikespeed_use_setting = int(self.dlg.Isochrones_BikeSpeed_Use.isChecked())
        s.setValue("otp_plugin/Isochrones_BikeSpeed_Use", self.isochrones_bikespeed_use_setting)
        self.isochrones_bikespeed_setting = float(self.dlg.Isochrones_BikeSpeed.value())
        s.setValue("otp_plugin/Isochrones_BikeSpeed", self.isochrones_bikespeed_setting)
        
        # Date
        self.isochrones_date_use_setting = int(self.dlg.Isochrones_Date_Use.isChecked())
        s.setValue("otp_plugin/Isochrones_Date_Use", self.isochrones_date_use_setting)
        self.isochrones_date_setting = self.dlg.Isochrones_Date.date()
        s.setValue("otp_plugin/Isochrones_Date", self.isochrones_date_setting)
        
        # Time
        self.isochrones_time_use_setting = int(self.dlg.Isochrones_Time_Use.isChecked())
        s.setValue("otp_plugin/Isochrones_Time_Use", self.isochrones_time_use_setting)
        self.isochrones_time_setting = self.dlg.Isochrones_Time.time()
        s.setValue("otp_plugin/Isochrones_Time", self.isochrones_time_setting)
        
        # ArriveBy
        self.isochrones_arriveby_use_setting = int(self.dlg.Isochrones_ArriveBy_Use.isChecked())
        s.setValue("otp_plugin/Isochrones_ArriveBy_Use", self.isochrones_arriveby_use_setting)
        self.isochrones_arriveby_setting = int(self.dlg.Isochrones_ArriveBy.isChecked())
        s.setValue("otp_plugin/Isochrones_ArriveBy", self.isochrones_arriveby_setting)
        
        # Wheelchair
        self.isochrones_wheelchair_use_setting = int(self.dlg.Isochrones_Wheelchair_Use.isChecked())
        s.setValue("otp_plugin/Isochrones_Wheelchair_Use", self.isochrones_wheelchair_use_setting)
        self.isochrones_wheelchair_setting = int(self.dlg.Isochrones_Wheelchair.isChecked())
        s.setValue("otp_plugin/Isochrones_Wheelchair", self.isochrones_wheelchair_setting)
        
        # Wait Reluctance
        self.isochrones_waitreluctance_use_setting = int(self.dlg.Isochrones_WaitReluctance_Use.isChecked())
        s.setValue("otp_plugin/Isochrones_WaitReluctance_Use", self.isochrones_waitreluctance_use_setting)
        self.isochrones_waitreluctance_setting = float(self.dlg.Isochrones_WaitReluctance.value())
        s.setValue("otp_plugin/Isochrones_WaitReluctance", self.isochrones_waitreluctance_setting)
        
        # Max Transfers
        self.isochrones_maxtransfers_use_setting = int(self.dlg.Isochrones_MaxTransfers_Use.isChecked())
        s.setValue("otp_plugin/Isochrones_MaxTransfers_Use", self.isochrones_maxtransfers_use_setting)
        self.isochrones_maxtransfers_setting = int(self.dlg.Isochrones_MaxTransfers.value())
        s.setValue("otp_plugin/Isochrones_MaxTransfers", self.isochrones_maxtransfers_setting)
        
        # Max Walkdistance
        self.isochrones_maxwalkdistance_use_setting = int(self.dlg.Isochrones_MaxWalkDistance_Use.isChecked())
        s.setValue("otp_plugin/Isochrones_MaxWalkDistance_Use", self.isochrones_maxwalkdistance_use_setting)
        self.isochrones_maxwalkdistance_setting = int(self.dlg.Isochrones_MaxWalkDistance.value())
        s.setValue("otp_plugin/Isochrones_MaxWalkDistance", self.isochrones_maxwalkdistance_setting)
        
        # Max Offroaddistance
        self.isochrones_maxoffroaddistance_use_setting = int(self.dlg.Isochrones_MaxOffroadDistance_Use.isChecked())
        s.setValue("otp_plugin/Isochrones_MaxOffroadDistance_Use", self.isochrones_maxoffroaddistance_use_setting)
        self.isochrones_maxoffroaddistance_setting = int(self.dlg.Isochrones_MaxOffroadDistance.value())
        s.setValue("otp_plugin/Isochrones_MaxOffroadDistance", self.isochrones_maxoffroaddistance_setting)
        
        # Precision Meters
        self.isochrones_precisionmeters_use_setting = int(self.dlg.Isochrones_PrecisionMeters_Use.isChecked())
        s.setValue("otp_plugin/Isochrones_PrecisionMeters_Use", self.isochrones_precisionmeters_use_setting)
        self.isochrones_precisionmeters_setting = int(self.dlg.Isochrones_PrecisionMeters.value())
        s.setValue("otp_plugin/Isochrones_PrecisionMeters", self.isochrones_precisionmeters_setting)
        
        # Cutoff Secs
        self.isochrones_interval_setting = self.dlg.Isochrones_Interval.toPlainText()
        s.setValue("otp_plugin/Isochrones_Interval", self.isochrones_interval_setting)
        
        # Mode
        self.isochrones_transportationmode_setting = self.dlg.Isochrones_TransportationMode.toPlainText()
        s.setValue("otp_plugin/Isochrones_TransportationMode", self.isochrones_transportationmode_setting)
        
        # Additional Parameters
        self.isochrones_additionalparameters_setting = self.dlg.Isochrones_AdditionalParameters.toPlainText()
        s.setValue("otp_plugin/Isochrones_AdditionalParameters", self.isochrones_additionalparameters_setting)
        
        self.iface.messageBar().pushMessage("Success", "Isochrone settings stored!", MESSAGE_CATEGORY, level=Qgis.Success, duration=3) 
        QgsMessageLog.logMessage("Isochrone settings stored!",MESSAGE_CATEGORY,Qgis.Info)
        
    def read_isochrone_variables(self):
        s = QgsSettings()
        
        # Walk Speed
        self.isochrones_walkspeed_use_setting = int(s.value("otp_plugin/Isochrones_WalkSpeed_Use", 0))
        self.dlg.Isochrones_WalkSpeed_Use.setChecked(self.isochrones_walkspeed_use_setting)
        self.isochrones_walkspeed_setting = float(s.value("otp_plugin/Isochrones_WalkSpeed", 4.828032))
        self.dlg.Isochrones_WalkSpeed.setValue(self.isochrones_walkspeed_setting)
        
        # Bike Speed
        self.isochrones_bikespeed_use_setting = int(s.value("otp_plugin/Isochrones_BikeSpeed_Use", 0))
        self.dlg.Isochrones_BikeSpeed_Use.setChecked(self.isochrones_bikespeed_use_setting)
        self.isochrones_bikespeed_setting = float(s.value("otp_plugin/Isochrones_BikeSpeed", 17.7))
        self.dlg.Isochrones_BikeSpeed.setValue(self.isochrones_bikespeed_setting)
        
        # Date
        self.isochrones_date_use_setting = int(s.value("otp_plugin/Isochrones_Date_Use", 1))
        self.dlg.Isochrones_Date_Use.setChecked(self.isochrones_date_use_setting)
        self.isochrones_date_setting = s.value("otp_plugin/Isochrones_Date", QtCore.QDateTime.currentDateTime())
        # I guess nobody understands this date 'stuff'....
        try:
            self.dlg.Isochrones_Date.setDateTime(self.isochrones_date_setting) # Standard value
        except:
            self.dlg.Isochrones_Date.setDate(self.isochrones_date_setting) # Stored value
        
        # Time
        self.isochrones_time_use_setting = int(s.value("otp_plugin/Isochrones_Time_Use", 1))
        self.dlg.Isochrones_Time_Use.setChecked(self.isochrones_time_use_setting)
        self.isochrones_time_setting = s.value("otp_plugin/Isochrones_Time", QTime.fromString('14:00:00'))
        self.dlg.Isochrones_Time.setTime(self.isochrones_time_setting)
        
        # Arrive By
        self.isochrones_arriveby_use_setting = int(s.value("otp_plugin/Isochrones_ArriveBy_Use", 0))
        self.dlg.Isochrones_ArriveBy_Use.setChecked(self.isochrones_arriveby_use_setting)
        self.isochrones_arriveby_setting = int(s.value("otp_plugin/Isochrones_ArriveBy", 0))
        self.dlg.Isochrones_ArriveBy.setChecked(self.isochrones_arriveby_setting)
        
        # Wheelchair
        self.isochrones_wheelchair_use_setting = int(s.value("otp_plugin/Isochrones_Wheelchair_Use", 0))
        self.dlg.Isochrones_Wheelchair_Use.setChecked(self.isochrones_wheelchair_use_setting)
        self.isochrones_wheelchair_setting = int(s.value("otp_plugin/Isochrones_Wheelchair", 0))
        self.dlg.Isochrones_Wheelchair.setChecked(self.isochrones_wheelchair_setting)
        
        # Wait Reluctance
        self.isochrones_waitreluctance_use_setting = int(s.value("otp_plugin/Isochrones_WaitReluctance_Use", 0))
        self.dlg.Isochrones_WaitReluctance_Use.setChecked(self.isochrones_waitreluctance_use_setting)
        self.isochrones_waitreluctance_setting = float(s.value("otp_plugin/Isochrones_WaitReluctance", 0.95))
        self.dlg.Isochrones_WaitReluctance.setValue(self.isochrones_waitreluctance_setting)
        
        # Max Transfers
        self.isochrones_maxtransfers_use_setting = int(s.value("otp_plugin/Isochrones_MaxTransfers_Use", 0))
        self.dlg.Isochrones_MaxTransfers_Use.setChecked(self.isochrones_maxtransfers_use_setting)
        self.isochrones_maxtransfers_setting = int(s.value("otp_plugin/Isochrones_MaxTransfers", 5))
        self.dlg.Isochrones_MaxTransfers.setValue(self.isochrones_maxtransfers_setting)
        
        # Max WalkDistance
        self.isochrones_maxwalkdistance_use_setting = int(s.value("otp_plugin/Isochrones_MaxWalkDistance_Use", 0))
        self.dlg.Isochrones_MaxWalkDistance_Use.setChecked(self.isochrones_maxwalkdistance_use_setting)
        self.isochrones_maxwalkdistance_setting = int(s.value("otp_plugin/Isochrones_MaxWalkDistance", 1000))
        self.dlg.Isochrones_MaxWalkDistance.setValue(self.isochrones_maxwalkdistance_setting)
        
        # Max OffRoadDistance
        self.isochrones_maxoffroaddistance_use_setting = int(s.value("otp_plugin/Isochrones_MaxOffroadDistance_Use", 0))
        self.dlg.Isochrones_MaxOffroadDistance_Use.setChecked(self.isochrones_maxoffroaddistance_use_setting)
        self.isochrones_maxoffroaddistance_setting = int(s.value("otp_plugin/Isochrones_MaxOffroadDistance", 150))
        self.dlg.Isochrones_MaxOffroadDistance.setValue(self.isochrones_maxoffroaddistance_setting)
        
        # Precision Meters
        self.isochrones_precisionmeters_use_setting = int(s.value("otp_plugin/Isochrones_PrecisionMeters_Use", 0))
        self.dlg.Isochrones_PrecisionMeters_Use.setChecked(self.isochrones_precisionmeters_use_setting)
        self.isochrones_precisionmeters_setting = int(s.value("otp_plugin/Isochrones_PrecisionMeters", 200))
        self.dlg.Isochrones_PrecisionMeters.setValue(self.isochrones_precisionmeters_setting)
        
        # Cutoff Sec
        self.isochrones_interval = s.value("otp_plugin/Isochrones_Interval", "60,120,180,240,300")
        if isinstance(self.isochrones_interval, str): self.dlg.Isochrones_Interval.setText(self.isochrones_interval)
        
        # Mode
        self.isochrones_transportationmode = s.value("otp_plugin/Isochrones_TransportationMode", "WALK,TRANSIT")
        if isinstance(self.isochrones_transportationmode, str): self.dlg.Isochrones_TransportationMode.setText(self.isochrones_transportationmode)
        
        # Additional Parameters
        self.isochrones_additionalparameters = s.value("otp_plugin/Isochrones_AdditionalParameters", "")
        if isinstance(self.isochrones_additionalparameters, str): self.dlg.Isochrones_AdditionalParameters.setText(self.isochrones_additionalparameters)
        
        #self.iface.messageBar().pushMessage("Success", "Function read_isochrone_variables running!", level=Qgis.Success, duration=3)

    def restore_isochrone_variables(self):
        s = QgsSettings()
        #DefaultSettings
        # Walk Speed
        self.isochrones_walkspeed_use_setting = int(0)
        self.dlg.Isochrones_WalkSpeed_Use.setChecked(self.isochrones_walkspeed_use_setting)
        self.isochrones_walkspeed_setting = float(4.828032)
        self.dlg.Isochrones_WalkSpeed.setValue(self.isochrones_walkspeed_setting)
        
        # Bike Speed
        self.isochrones_bikespeed_use_setting = int(0)
        self.dlg.Isochrones_BikeSpeed_Use.setChecked(self.isochrones_bikespeed_use_setting)
        self.isochrones_bikespeed_setting = float(17.7)
        self.dlg.Isochrones_BikeSpeed.setValue(self.isochrones_bikespeed_setting)
        
        # Date #####
        self.isochrones_date_use_setting = int(1)
        self.dlg.Isochrones_Date_Use.setChecked(self.isochrones_date_use_setting)
        self.isochrones_date_setting = QDateTime(QtCore.QDateTime.currentDateTime())
        self.dlg.Isochrones_Date.setDateTime(self.isochrones_date_setting)
        
        # Time
        self.isochrones_time_use_setting = int(1)
        self.dlg.Isochrones_Time_Use.setChecked(self.isochrones_time_use_setting)
        self.isochrones_time_setting = QTime.fromString('14:00:00')
        self.dlg.Isochrones_Time.setTime(self.isochrones_time_setting)
        
        # Arrive By
        self.isochrones_arriveby_use_setting = int(0)
        self.dlg.Isochrones_ArriveBy_Use.setChecked(self.isochrones_arriveby_use_setting)
        self.isochrones_arriveby_setting = int(0)
        self.dlg.Isochrones_ArriveBy.setChecked(self.isochrones_arriveby_setting)
        
        # Wheelchair
        self.isochrones_wheelchair_use_setting = int(0)
        self.dlg.Isochrones_Wheelchair_Use.setChecked(self.isochrones_wheelchair_use_setting)
        self.isochrones_wheelchair_setting = int(0)
        self.dlg.Isochrones_Wheelchair.setChecked(self.isochrones_wheelchair_setting)
        
        # Wait Reluctance
        self.isochrones_waitreluctance_use_setting = int(0)
        self.dlg.Isochrones_WaitReluctance_Use.setChecked(self.isochrones_waitreluctance_use_setting)
        self.isochrones_waitreluctance_setting = float(0.95)
        self.dlg.Isochrones_WaitReluctance.setValue(self.isochrones_waitreluctance_setting)
        
        # Max Transfers
        self.isochrones_maxtransfers_use_setting = int(0)
        self.dlg.Isochrones_MaxTransfers_Use.setChecked(self.isochrones_maxtransfers_use_setting)
        self.isochrones_maxtransfers_setting = int(5)
        self.dlg.Isochrones_MaxTransfers.setValue(self.isochrones_maxtransfers_setting)
        
        # Max WalkDistance
        self.isochrones_maxwalkdistance_use_setting = int(0)
        self.dlg.Isochrones_MaxWalkDistance_Use.setChecked(self.isochrones_maxwalkdistance_use_setting)
        self.isochrones_maxwalkdistance_setting = int(1000)
        self.dlg.Isochrones_MaxWalkDistance.setValue(self.isochrones_maxwalkdistance_setting)
        
        # Max OffRoadDistance
        self.isochrones_maxoffroaddistance_use_setting = int(0)
        self.dlg.Isochrones_MaxOffroadDistance_Use.setChecked(self.isochrones_maxoffroaddistance_use_setting)
        self.isochrones_maxoffroaddistance_setting = int(150)
        self.dlg.Isochrones_MaxOffroadDistance.setValue(self.isochrones_maxoffroaddistance_setting)
        
        # Precision Meters
        self.isochrones_precisionmeters_use_setting = int(0)
        self.dlg.Isochrones_PrecisionMeters_Use.setChecked(self.isochrones_precisionmeters_use_setting)
        self.isochrones_precisionmeters_setting = int(200)
        self.dlg.Isochrones_PrecisionMeters.setValue(self.isochrones_precisionmeters_setting)
        
        # Cutoff Sec
        self.isochrones_interval = ""
        if isinstance(self.isochrones_interval, str): self.dlg.Isochrones_Interval.setText(self.isochrones_interval)
        
        # Mode
        self.isochrones_transportationmode = ""
        if isinstance(self.isochrones_transportationmode, str): self.dlg.Isochrones_TransportationMode.setText(self.isochrones_transportationmode)
        
        # Additional Parameters
        self.isochrones_additionalparameters = ""
        if isinstance(self.isochrones_additionalparameters, str): self.dlg.Isochrones_AdditionalParameters.setText(self.isochrones_additionalparameters)
        
        self.iface.messageBar().pushMessage("Success", "Default isochrone settings restored!", MESSAGE_CATEGORY, level=Qgis.Success, duration=3)
        QgsMessageLog.logMessage("Default isochrone settings restored!",MESSAGE_CATEGORY,Qgis.Info)
      
    # Source: https://stackoverflow.com/a/33557535/8947209 (slightly modified)
    def decode_polyline(self, polyline_str):
        index, lat, lng = 0, 0, 0
        #coordinates = []
        pointlist = []
        changes = {'latitude': 0, 'longitude': 0}
    
        # Coordinates have variable length when encoded, so just keep
        # track of whether we've hit the end of the string. In each
        # while loop iteration, a single coordinate is decoded.
        while index < len(polyline_str):
            # Gather lat/lon changes, store them in a dictionary to apply them later
            for unit in ['latitude', 'longitude']: 
                shift, result = 0, 0

                while True:
                    byte = ord(polyline_str[index]) - 63
                    index+=1
                    result |= (byte & 0x1f) << shift
                    shift += 5
                    if not byte >= 0x20:
                        break

                if (result & 1):
                    changes[unit] = ~(result >> 1)
                else:
                    changes[unit] = (result >> 1)

            lat += changes['latitude']
            lng += changes['longitude']
            
            qgspointgeom = QgsPoint(float(lng / 100000.0),float(lat / 100000.0))
            pointlist.append(qgspointgeom)

            #coordinates.append((lat / 100000.0, lng / 100000.0)) # original code, but we dont need a tuple of coords, only the qgspoints

        return pointlist
        
        
    def check_server_status(self):
        #foldername, _filter = QFileDialog.getExistingDirectory(self.dlg, "Open Directory","",ShowDirsOnly)
        #filename, _filter = QFileDialog.getSaveFileName(self.dlg, "Select output file ","", '*.*')
        #self.dlg.GeneralSettings_SavePath.setText(filename)
        #print(self.serverurl)
        
        #Run Store-Variables-Function and Read-Stored-Variables-Function before so users do not have to click save button before checking status
        self.store_general_variables()
        self.read_general_variables()
        servercheckrequest = urllib.request.Request(str(self.serverurl))
        try:
            urllib.request.urlopen(servercheckrequest)
            self.dlg.GeneralSettings_ServerStatusResult.setText("Server is Online :)")
            self.dlg.GeneralSettings_ServerStatusResult.setStyleSheet("background-color: green; color: white ")
        except urllib.error.URLError as urlerror:
            self.dlg.GeneralSettings_ServerStatusResult.setText("Error: " + str(urlerror.reason))
            self.dlg.GeneralSettings_ServerStatusResult.setStyleSheet("background-color: red; color: white ")
        except urllib.error.HTTPError as httperror:
            self.dlg.GeneralSettings_ServerStatusResult.setText("Error: " + str(httperror.code))
            self.dlg.GeneralSettings_ServerStatusResult.setStyleSheet("background-color: red; color: white ")

    
    def routes_request_routes(self):
        # clear and initialize vars and stuff
        route_url = None
        route_error = None
        r = None
        inputlayer_outfeat = None
        debug_info = None
        route_uid_counter = 0
        route_id_counter = 0
        
        QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info)
        QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info)
        QgsMessageLog.logMessage("##### Routes job starting @ " + str(datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")) + " #####",MESSAGE_CATEGORY,Qgis.Info)
        QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info)
        routes_starttime = datetime.now()
        
        # Getting fieldtypes and names of selected matchingfields
        sourceidfieldname = self.dlg.Routes_SelectInputField_Source.currentField()
        sourceidfieldindex = self.routes_selectedlayer_source.fields().indexFromName(sourceidfieldname)
        targetidfieldname = str(self.dlg.Routes_SelectInputField_Target.currentField())
        targetidfieldindex = self.routes_selectedlayer_target.fields().indexFromName(targetidfieldname)
        for field in self.routes_selectedlayer_source.fields():
            if field.name() == sourceidfieldname:
                sourceidfieldtype = field.type()
        for field in self.routes_selectedlayer_target.fields():
            if field.name() == targetidfieldname:
                targetidfieldtype = field.type()
                
                
        # Create the Output-Vectorlayer
        routes_memorylayer_vl = QgsVectorLayer("LineString?crs=epsg:4326", "Routes", "memory") # Create temporary polygon layer (output file)
        routes_memorylayer_pr = routes_memorylayer_vl.dataProvider() # No idea what pr stands for, just copied this name from all the examples on the web... probably provider??
        routes_memorylayer_vl.startEditing() # Enter editing mode
        routes_memorylayer_pr.addAttributes([ # Master for attributes and varnames
            QgsField("Route_LegID",QVariant.Int),
            QgsField("Route_RouteID", QVariant.Int),
            QgsField("Route_RelationID", QVariant.Int),
            QgsField("Route_From", sourceidfieldtype), # !
            QgsField("Route_To", targetidfieldtype), # !
            QgsField("Route_Error", QVariant.String),
            QgsField("Route_ErrorID", QVariant.Int),
            QgsField("Route_ErrorDescription", QVariant.String),
            QgsField("Route_URL", QVariant.String),
            QgsField("Route_From_Lat", QVariant.Double, len=4, prec=8),
            QgsField("Route_From_Lon", QVariant.Double, len=4, prec=8),
            QgsField("Route_From_StopId", QVariant.String),
            QgsField("Route_From_StopCode", QVariant.String),
            QgsField("Route_From_Name", QVariant.String),
            QgsField("Route_From_StartTime", QVariant.DateTime),            
            QgsField("Route_To_Lat", QVariant.Double, len=4, prec=8),
            QgsField("Route_To_Lon", QVariant.Double, len=4, prec=8),
            QgsField("Route_To_StopId", QVariant.String),
            QgsField("Route_To_StopCode", QVariant.String),
            QgsField("Route_To_Name", QVariant.String),      
            QgsField("Route_To_EndTime", QVariant.DateTime),
            QgsField("Route_Total_Mode", QVariant.String),
            QgsField("Route_Total_Duration", QVariant.Int),
            QgsField("Route_Total_Distance", QVariant.Double),
            QgsField("Route_Total_TransitTime", QVariant.Int),
            QgsField("Route_Total_WaitingTime", QVariant.Int),
            QgsField("Route_Total_WalkTime", QVariant.Int),
            QgsField("Route_Total_WalkDistance", QVariant.Double),
            QgsField("Route_Total_Transfers", QVariant.Int),
            QgsField("Route_Leg_StartTime", QVariant.DateTime),
            QgsField("Route_Leg_DepartureDelay", QVariant.Int),
            QgsField("Route_Leg_EndTime", QVariant.DateTime),
            QgsField("Route_Leg_ArrivalDelay", QVariant.Int),
            QgsField("Route_Leg_Duration", QVariant.Int),
            QgsField("Route_Leg_Distance", QVariant.Double),
            QgsField("Route_Leg_Mode", QVariant.String),
            QgsField("Route_Leg_From_Lat", QVariant.Double, len=4, prec=8),
            QgsField("Route_Leg_From_Lon", QVariant.Double, len=4, prec=8),
            QgsField("Route_Leg_From_StopId", QVariant.String),
            QgsField("Route_Leg_From_StopCode", QVariant.String),
            QgsField("Route_Leg_From_Name", QVariant.String),
            QgsField("Route_Leg_From_Departure", QVariant.DateTime),
            QgsField("Route_Leg_To_Lat", QVariant.Double, len=4, prec=8),
            QgsField("Route_Leg_To_Lon", QVariant.Double, len=4, prec=8),
            QgsField("Route_Leg_To_StopId", QVariant.String),
            QgsField("Route_Leg_To_StopCode", QVariant.String),
            QgsField("Route_Leg_To_Name", QVariant.String),
            QgsField("Route_Leg_To_Arrival", QVariant.DateTime)
            ]) # Add fields to outputlayer
        inputlayer_outFeat = QgsFeature() # set QgsFeature
        routes_memorylayer_vl.updateFields()
        routes_memorylayer_vl.commitChanges() # save empty layer with fields
        routes_memorylayer_vl.startEditing() # start editing again

        # Fieldindex as dictionary to avoid a mess
        fieldindexcounter = 0 # start with index 0
        fieldindexdict = {} # empty dictionary
        for field in routes_memorylayer_vl.fields(): # iterate through field list we just created above
            x = str(field.name()).lower() # convert to lowercase, string
            fieldindexdict[fieldindexcounter] = x # assign index as key and fieldname as value
            if '_url' in x:
                fieldindex_position_of_last_alwaysneededfield = fieldindexcounter
            if 'route_total_distance' in x:
                fieldindex_position_of_routetotaldistance = fieldindexcounter
            fieldindexcounter += 1
        len_fieldindexdict = len(fieldindexdict)
        
        fieldindexcounter_source = 0 + len_fieldindexdict
        fieldindexdict_source = {}        
        for field in self.routes_selectedlayer_source.fields(): # Dont just copy all fieldnames of inputlayers in case both inputs have identical names... add Source_ and Target_ as prefix
            routes_memorylayer_pr.addAttributes([QgsField('Source_' + str(field.name()), field.type())]) # Old fieldname + Source_ as prefix. Keep original field type
            x = 'source_' + str(field.name()).lower() # add to fieldindexdictionary
            fieldindexdict_source[fieldindexcounter_source] = x # add to fieldindexdictionary
            fieldindexcounter_source += 1 
        len_fieldindexdict_source = len(fieldindexdict_source)

        fieldindexcounter_target = 0 + len_fieldindexdict + len_fieldindexdict_source
        fieldindexdict_target = {}
        for field in self.routes_selectedlayer_target.fields(): # Dont just copy all fieldnames of inputlayers in case both inputs have identical names... add Source_ and Target_ as prefix
            routes_memorylayer_pr.addAttributes([QgsField('Target_' + str(field.name()), field.type())]) # Old fieldname + Target_ as prefix. Keep original field type       
            x = 'target_' + str(field.name()).lower() # add to fieldindexdictionary
            fieldindexdict_target[fieldindexcounter_target] = x # add to fieldindexdictionary
            fieldindexcounter_target += 1     
        len_fieldindexdict_target = len(fieldindexdict_target)            
        #print(fieldindexdict)
        
        # To optimize speed of loop in case only routes for matching fields shall be created: Create a dictionary for both layers
        # See: https://gis.stackexchange.com/questions/377807/using-an-attribute-index-to-find-matching-attributes-of-two-layers-faster and https://stackoverflow.com/a/64597197/8947209
        dict_source = {}
        dict_target = {}
        for feat_source in self.routes_selectedlayer_source.getFeatures():
            dict_source[feat_source.id()] = feat_source.attribute(sourceidfieldindex) # feature id is used as key and attribute as value
        for feat_target in self.routes_selectedlayer_target.getFeatures():
            dict_target[feat_target.id()] = feat_target.attribute(targetidfieldindex) # feature id is used as key and attribute as value
        
        # Create matching dictionary for performance optimization
        # See: https://gis.stackexchange.com/questions/377807/using-an-attribute-index-to-find-matching-attributes-of-two-layers-faster and https://stackoverflow.com/a/64597197/8947209
        dic2 = {}
        dic3 = []
        route_matches = {}
        if self.dlg.Routes_OnlyMatching.isChecked() == True: # only routes from source points which match with target points ids
            for i in dict_target.keys():
                elem_target = dict_target[i]
                if dic2.get(elem_target, None):
                    dic2[elem_target].append(i)
                else:
                    dic2[elem_target] = [i]
            for i in dict_source.keys():
                elem_source = dict_source[i]
                x = dic2.get(elem_source, None)
                if x:
                    route_matches[i] = x
        else: # Route from all source points to all target points
            for i in dict_target.keys():
                dic3.append(i)
            for i in dict_source.keys():
                route_matches[i] = dic3
        #print(route_matches)
        #print(dict_source)
        #print(dict_target)
        
        # Number of total routes to calculate
        n_totalrelations = 0
        for v in route_matches.values():
            # checking whether the value is a list
            if isinstance(v, list):
                n_totalrelations += len(v)
        #print(n_totalrelations)
        if n_totalrelations == 0:
            self.iface.messageBar().pushMessage("Warning", " No Routes to create / no matching attributes", MESSAGE_CATEGORY, level=Qgis.Warning, duration=6)
            QgsMessageLog.logMessage("Warning! No Routes to create. Probably due to no matching attributes found or empty layer(s).",MESSAGE_CATEGORY,Qgis.Warning)
        
        # Preparing Progressbar
        progressbar_featurecount = n_totalrelations
        progressbar_percent = 1 # Use 1 on start to show users that something is running if the first one takes a while
        progressbar_counter = 0
        self.dlg.Routes_ProgressBar.setValue(progressbar_percent)    
        
        # General Settings
        serverurl = self.serverurl #'https://api.digitransit.fi/routing/v1/routers/hsl/' #self.dlg.GeneralSettings_ServerURL.toPlainText()
        
        # Setting up Override Button context
        if self.dlg.Routes_DataDefinedLayer_Source.isChecked() == True:
            ctx = QgsExpressionContext(QgsExpressionContextUtils.globalProjectLayerScopes(self.routes_selectedlayer_source)) #This context will be able to evaluate global, project, and layer variables
        elif self.dlg.Routes_DataDefinedLayer_Target.isChecked() == True:
            ctx = QgsExpressionContext(QgsExpressionContextUtils.globalProjectLayerScopes(self.routes_selectedlayer_target)) #This context will be able to evaluate global, project, and layer variables
        else:
            ctx = QgsExpressionContext(QgsExpressionContextUtils.globalProjectLayerScopes(self.routes_selectedlayer_source)) #This context will be able to evaluate global, project, and layer variables
        
        # Preparing Features
        routes_inputlayer_features_source = self.routes_selectedlayer_source.getFeatures()
        routes_inputlayer_features_target = self.routes_selectedlayer_target.getFeatures()
        
        # Preparing Transformation to WGS 84
        sourcecrs1 = QgsCoordinateReferenceSystem(self.routes_selectedlayer_source.crs().authid()) # Read CRS of input layer
        sourcecrs2 = QgsCoordinateReferenceSystem(self.routes_selectedlayer_target.crs().authid()) # Read CRS of input layer
        destcrs = QgsCoordinateReferenceSystem("EPSG:4326") # and set destination CRS to WGS 84 (OTP can only understand EPSG:4326) 
        tr1 = QgsCoordinateTransform(sourcecrs1, destcrs, QgsProject.instance()) # Setting up transformation
        tr2 = QgsCoordinateTransform(sourcecrs2, destcrs, QgsProject.instance()) # Setting up transformation
        
        # Counter
        route_legid = 0
        route_routeid = 0
        route_relationid = 0
        route_from = ''
        route_to = ''
        notavailablestring = None #'not available'
        notavailableint = None #0
        notavailableothers = None
        
        # Pseudopointlist for errors in decode polyline
        errorlinegeom = []
        errorlinegeomp1 = QgsPoint(float(-0.1),float(0.0))
        errorlinegeom.append(errorlinegeomp1)
        errorlinegeomp2 = QgsPoint(float(0.1),float(0.0))
        errorlinegeom.append(errorlinegeomp2)
        
        QgsProject.instance().addMapLayer(routes_memorylayer_vl)# Show in project
        
        # Request the routes
        for source, target in route_matches.items(): # loop through key (source) and value (target) of matching dictionary
            i = 0 # counter to access value in values            
            for l in target: # loop through list of current value
                progressbar_counter = progressbar_counter + 1
                route_relationid += 1 
                
                source_fid = source # key of matching dict represents keys of dict_source and therefore featureids of sourcelayer
                target_fid = target[i] # values of matching dict represent keys of dict_target and therefore featureids of targetlayer                
                sourcelayer_feature = self.routes_selectedlayer_source.getFeature(source_fid)
                targetlayer_feature = self.routes_selectedlayer_target.getFeature(target_fid)
                
                # Override Button
                if self.dlg.Routes_DataDefinedLayer_Source.isChecked() == True:
                    ctx.setFeature(sourcelayer_feature)
                elif self.dlg.Routes_DataDefinedLayer_Target.isChecked() == True:
                    ctx.setFeature(targetlayer_feature)
                else:
                    ctx.setFeature(sourcelayer_feature)
                
                # Values of current source and target ids
                if self.routes_selectedlayer_source.getFeature(source_fid).attribute(sourceidfieldindex) is None: # Prevent error when value is NULL
                    source_feature_idvalue = None
                else:
                    source_feature_idvalue = self.routes_selectedlayer_source.getFeature(source_fid).attribute(sourceidfieldindex)
                if self.routes_selectedlayer_target.getFeature(target_fid).attribute(targetidfieldindex) is None: # Prevent error when value is NULL
                    target_feature_idvalue = None
                else:
                    target_feature_idvalue = self.routes_selectedlayer_target.getFeature(target_fid).attribute(targetidfieldindex)
                
                route_from = source_feature_idvalue
                route_to = target_feature_idvalue
                
                geom_source = self.routes_selectedlayer_source.getFeature(source_fid).geometry()
                geom_target = self.routes_selectedlayer_target.getFeature(target_fid).geometry()
                geom_source.transform(tr1) # Transform geometry to WGS 84
                geom_target.transform(tr2) # Transform geometry to WGS 84
                pointgeom_source = geom_source.asPoint() #Read Point geometry
                pointgeom_target = geom_target.asPoint() #Read Point geometry
                x_source = round(pointgeom_source.x(),8)
                y_source = round(pointgeom_source.y(),8)
                x_target = round(pointgeom_target.x(),8)
                y_target = round(pointgeom_target.y(),8)
                QgsMessageLog.logMessage("Relation #" + str(route_relationid) + " of " + str(n_totalrelations)  + " total relations.",MESSAGE_CATEGORY,Qgis.Info)
                QgsMessageLog.logMessage("Relation from Source '" + str(source_feature_idvalue) + "' (" + str(y_source) + "," + str(x_source) + ") to Target '" + str(target_feature_idvalue) + "' (" + str(y_target) + "," + str(x_target) + ")",MESSAGE_CATEGORY,Qgis.Info)
                
                #Check where to gather attributes from: GUI or Layer? 
                #WalkSpeed
                if self.dlg.Routes_WalkSpeed_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.Routes_WalkSpeed_Override.isActive() == True: # Check if override button shall be used
                        routes_walkspeed_value, irrelevantsuccessstorage = self.dlg.Routes_WalkSpeed_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        routes_walkspeed_value = self.dlg.Routes_WalkSpeed.value() # Receiving Value from GUI: QDoubleSpinBox
                    if routes_walkspeed_value is not None: # Check if received value is NULL
                        routes_walkspeed_ms = float(routes_walkspeed_value) * 0.27777777777778 # Convert float and km/h to m/s
                        routes_walkspeed_urlstring = '&walkSpeed=' + str(round(routes_walkspeed_ms,6)) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        routes_walkspeed_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    routes_walkspeed_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
 
                #BikeSpeed
                if self.dlg.Routes_BikeSpeed_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.Routes_BikeSpeed_Override.isActive() == True: # Check if override button shall be used
                        routes_bikespeed_value, irrelevantsuccessstorage = self.dlg.Routes_BikeSpeed_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        routes_bikespeed_value = self.dlg.Routes_BikeSpeed.value() # Receiving Value from GUI: QDoubleSpinBox
                    if routes_bikespeed_value is not None: # Check if received value is NULL
                        routes_bikespeed_ms = float(routes_bikespeed_value) * 0.27777777777778 # Convert float and km/h to m/s
                        routes_bikespeed_urlstring = '&bikeSpeed=' + str(round(routes_bikespeed_ms,6)) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        routes_bikespeed_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    routes_bikespeed_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)

                #Date
                if self.dlg.Routes_Date_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.Routes_Date_Override.isActive() == True: # Check if override button shall be used
                        routes_date_value, irrelevantsuccessstorage = self.dlg.Routes_Date_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        routes_date_value = self.dlg.Routes_Date.date().toString("yyyy-MM-dd") # Receiving Value from GUI: QDateEdit
                    if routes_date_value is not None: # Check if received value is NULL
                        routes_date_urlstring = '&date=' + str(routes_date_value) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        routes_date_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    routes_date_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                
                #Time
                if self.dlg.Routes_Time_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.Routes_Time_Override.isActive() == True: # Check if override button shall be used
                        routes_time_value, irrelevantsuccessstorage = self.dlg.Routes_Time_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        routes_time_value = self.dlg.Routes_Time.time().toString("HH:mm:ss") # Receiving Value from GUI: QTimeEdit
                    if routes_time_value is not None: # Check if received value is NULL
                        routes_time_urlstring = '&time=' + str(routes_time_value) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        routes_time_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    routes_time_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                
                #ArriveBy
                if self.dlg.Routes_ArriveBy_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.Routes_ArriveBy_Override.isActive() == True: # Check if override button shall be used
                        routes_arriveby_value, irrelevantsuccessstorage = self.dlg.Routes_ArriveBy_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        routes_arriveby_value = self.dlg.Routes_ArriveBy.isChecked() # Receiving Value from GUI: QCheckBox
                    if routes_arriveby_value is not None: # Check if received value is NULL
                        routes_arriveby_urlstring = '&arriveBy=' + str(routes_arriveby_value) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        routes_arriveby_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    routes_arriveby_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                
                #Wheelchair
                if self.dlg.Routes_Wheelchair_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.Routes_Wheelchair_Override.isActive() == True: # Check if override button shall be used
                        routes_wheelchair_value, irrelevantsuccessstorage = self.dlg.Routes_Wheelchair_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        routes_wheelchair_value = self.dlg.Routes_Wheelchair.isChecked() # Receiving Value from GUI: QCheckBox
                    if routes_wheelchair_value is not None: # Check if received value is NULL
                        routes_wheelchair_urlstring = '&wheelchair=' + str(routes_wheelchair_value) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        routes_wheelchair_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    routes_wheelchair_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                
                #WaitReluctance
                if self.dlg.Routes_WaitReluctance_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.Routes_WaitReluctance_Override.isActive() == True: # Check if override button shall be used
                        routes_waitreluctance_value, irrelevantsuccessstorage = self.dlg.Routes_WaitReluctance_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        routes_waitreluctance_value = self.dlg.Routes_WaitReluctance.value() # Receiving Value from GUI: QDoubleSpinBox
                    if routes_waitreluctance_value is not None: # Check if received value is NULL
                        routes_waitreluctance_float = round(float(routes_waitreluctance_value),2)
                        routes_waitreluctance_urlstring = '&waitReluctance=' + str(routes_waitreluctance_float) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        routes_waitreluctance_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    routes_waitreluctance_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                
                #MaxTransfers
                if self.dlg.Routes_MaxTransfers_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.Routes_MaxTransfers_Override.isActive() == True: # Check if override button shall be used
                        routes_maxtransfers_value, irrelevantsuccessstorage = self.dlg.Routes_MaxTransfers_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        routes_maxtransfers_value = self.dlg.Routes_MaxTransfers.value() # Receiving Value from GUI: QSpinBox
                    if routes_maxtransfers_value is not None: # Check if received value is NULL
                        routes_maxtransfers_urlstring = '&maxTransfers=' + str(routes_maxtransfers_value) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        routes_maxtransfers_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    routes_maxtransfers_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
             
                #MaxWalkDistance
                if self.dlg.Routes_MaxWalkDistance_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.Routes_MaxWalkDistance_Override.isActive() == True: # Check if override button shall be used
                        routes_maxwalkdistance_value, irrelevantsuccessstorage = self.dlg.Routes_MaxWalkDistance_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        routes_maxwalkdistance_value = self.dlg.Routes_MaxWalkDistance.value() # Receiving Value from GUI: QSpinBox
                    if routes_maxwalkdistance_value is not None: # Check if received value is NULL
                        routes_maxwalkdistance_urlstring = '&maxWalkDistance=' + str(routes_maxwalkdistance_value) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        routes_maxwalkdistance_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    routes_maxwalkdistance_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
             
                #MaxOffroadDistance
                if self.dlg.Routes_MaxOffroadDistance_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.Routes_MaxOffroadDistance_Override.isActive() == True: # Check if override button shall be used
                        routes_maxoffroaddistance_value, irrelevantsuccessstorage = self.dlg.Routes_MaxOffroadDistance_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        routes_maxoffroaddistance_value = self.dlg.Routes_MaxOffroadDistance.value() # Receiving Value from GUI: QSpinBox
                    if routes_maxoffroaddistance_value is not None: # Check if received value is NULL
                        routes_maxoffroaddistance_urlstring = '&offRoadDistanceMeters=' + str(routes_maxoffroaddistance_value) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        routes_maxoffroaddistance_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    routes_maxoffroaddistance_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)

                #Iterinaries
                if self.dlg.Routes_Iterinaries_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.Routes_Iterinaries_Override.isActive() == True: # Check if override button shall be used
                        routes_iterinaries_value, irrelevantsuccessstorage = self.dlg.Routes_Iterinaries_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        routes_iterinaries_value = self.dlg.Routes_Iterinaries.value() # Receiving Value from GUI: QSpinBox
                    if routes_iterinaries_value is not None: # Check if received value is NULL
                        routes_iterinaries_urlstring = '&numItineraries=' + str(routes_iterinaries_value) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        routes_iterinaries_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    routes_iterinaries_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)

                #Optimize
                if self.dlg.Routes_Optimize_Use.isChecked() == True: # Check if option shall be used                
                    if self.dlg.Routes_Optimize_Override.isActive() == True: # Check if override button shall be used
                        routes_optimize_value, irrelevantsuccessstorage = self.dlg.Routes_Optimize_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                    else:
                        routes_optimize_value = self.dlg.Routes_Optimize.currentText() # Receiving Value from GUI: QComboBox
                    if routes_optimize_value is not None: # Check if received value is NULL
                        routes_optimize_urlstring = '&optimize=' + str(routes_optimize_value) # Concatenate to URL string if option is used and value is not NULL
                    else:
                        routes_optimize_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
                else:
                    routes_optimize_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                    
                #Transportation Mode
                if self.dlg.Routes_TransportationMode_Override.isActive() == True:
                    routes_transportationmode_value, irrelevantsuccessstorage = self.dlg.Routes_TransportationMode_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    routes_transportationmode_value = self.dlg.Routes_TransportationMode.toPlainText() #Receiving Value from GUI: QTextEdit
                if not routes_transportationmode_value: # Check if it is NULL
                    routes_transportationmode_value = 'WALK,TRANSIT' # Make sure Mode is not empty because it is a must have parameter
                routes_transportationmode_urlstring = "&mode=" + routes_transportationmode_value.upper() # Make sure Mode is given as uppercase to prevent possible server errors (not sure how otp handels this exactly)
                route_total_mode = routes_transportationmode_value
                
                #Additional Parameters
                if self.dlg.Routes_AdditionalParameters_Override.isActive() == True:
                    routes_additionalparameters_value, irrelevantsuccessstorage = self.dlg.Routes_AdditionalParameters_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    routes_additionalparameters_value = self.dlg.Routes_AdditionalParameters.toPlainText() #Receiving Value from GUI: QTextEdit
                if routes_additionalparameters_value is not None: # If Additional Parameters are filled, use it
                    routes_additionalparameters_urlstring = str(routes_additionalparameters_value) # Create the string
                else: # If Additional Parameters are not filled, do not use it
                    routes_additionalparameters_urlstring = '' # Create the string (Empty, because it is not used, not NULL!!)
                
                #Example URL: https://api.digitransit.fi/routing/v1/routers/hsl/plan?numIterinaries=5&fromPlace=60.166023,24.97278&toPlace=60.19794,25.04453&mode=WALK,TRANSIT
                #https://api.digitransit.fi/routing/v1/routers/hsl/plan?numIterinaries=5&fromPlace=60.166023,24.97278&toPlace=60.19794,25.04453&mode=WALK,TRANSIT
                #Concat URL and convert to string
                route_url = (str(serverurl) + "plan?" + # Add Plan request to server url
                                "fromPlace=" + str(y_source) + "," + str(x_source) + # concatenate x and y coordinates as string
                                "&toPlace=" + str(y_target) + "," + str(x_target) + 
                                routes_transportationmode_urlstring + #
                                routes_walkspeed_urlstring + #
                                routes_bikespeed_urlstring + #
                                routes_date_urlstring + #
                                routes_time_urlstring + #
                                routes_arriveby_urlstring + #
                                routes_wheelchair_urlstring + #
                                routes_waitreluctance_urlstring + #
                                routes_maxtransfers_urlstring + #
                                routes_maxwalkdistance_urlstring + #
                                routes_maxoffroaddistance_urlstring + #
                                routes_iterinaries_urlstring +
                                routes_optimize_urlstring +
                                routes_additionalparameters_urlstring # Additional Parameters entered as OTP-Readable string -> User responsibility
                                )
                
                testurl = 'https://api.digitransit.fi/routing/v1/routers/hsl/plan?numIterinaries=5&fromPlace=60.166023,24.97278&toPlace=60.19794,25.04453&mode=WALK,TRANSIT'
                route_url = route_url # for testing
                QgsMessageLog.logMessage(route_url,MESSAGE_CATEGORY,Qgis.Info)
                route_headers = {"accept":"application/json"} # this plugin only works for json responses
                
                route_error = 'Success: No Error'
                route_error_bool = False
                route_errorid = None
                route_errordescription = None
                route_errormessage = None
                route_errornopath = None
                
                try: # Try to request route
                    route_request = urllib.request.Request(route_url, headers=route_headers)
                    try: # Try to receive response
                        route_response = urllib.request.urlopen(route_request)
                        try: # Try to read response data
                            response_data = route_response.read()
                            encoding = route_response.info().get_content_charset('utf-8')
                            route_data = json.loads(response_data.decode(encoding))
                            try: # Check if response says Error
                                route_error = 'Error: No Route'
                                route_error_bool = True
                                route_errorid = route_data['error']['id']
                                route_errordescription = route_data['error']['msg']
                                route_errormessage = route_data['error']['message']
                                route_errornopath = route_data['error']['noPath']
                            except:
                                route_error = 'Success: No Error'
                                route_error_bool = False
                        except:
                            route_error = 'Error reading response data'
                            route_error_bool = True
                    except:
                        route_error = 'Error receiving response'
                        route_error_bool = True
                except:
                    route_error = 'Error requesting the route'
                    route_error_bool = True
                

                #print(route_data)
                # Reading response
                if route_error_bool == False:
                    # Get general informations. Note that not all are available in all responses: use try/except
                    try:
                        route_from_lat = route_data['plan']['from']['lat']
                        route_from_lon = route_data['plan']['from']['lon']
                    except:
                        route_from_lat = notavailableint
                        route_from_lon = notavailableint                     
                    try:
                        route_from_stopid = route_data['plan']['from']['stopId']
                    except:
                        route_from_stopid = notavailablestring
                    try:
                        route_from_stopcode = route_data['plan']['from']['stopCode']
                    except:
                        route_from_stopcode = notavailablestring
                    try:
                        route_from_name = route_data['plan']['from']['name']
                    except:
                        route_from_name = notavailablestring
                    try:
                        route_to_lat = route_data['plan']['to']['lat']
                        route_to_lon = route_data['plan']['to']['lon']
                    except:
                        route_to_lat = notavailableint
                        route_to_lon = notavailableint                     
                    try:
                        route_to_stopid = route_data['plan']['to']['stopId']
                    except:
                        route_to_stopid = notavailablestring
                    try:
                        route_to_stopcode = route_data['plan']['to']['stopCode']
                    except:
                        route_to_stopcode = notavailablestring
                    try:
                        route_to_name = route_data['plan']['to']['name']
                    except:
                        route_to_name = notavailablestring
                    
                    # loop through iterinaries    
                    for iter in route_data['plan']['itineraries']: 
                        route_routeid += 1
                        try:
                            route_from_starttime = iter['startTime']
                            route_from_starttime = datetime.fromtimestamp(int(route_from_starttime)/1000)
                            route_from_starttime = QDateTime.fromString(str(route_from_starttime),'yyyy-MM-dd hh:mm:ss')
                        except:
                            route_from_starttime = notavailableothers
                        try:
                            route_to_endtime = iter['endTime']
                            route_to_endtime = datetime.fromtimestamp(int(route_to_endtime)/1000)
                            route_to_endtime = QDateTime.fromString(str(route_to_endtime),'yyyy-MM-dd hh:mm:ss')                            
                        except:
                            route_to_endtime = notavailableothers
                        try:
                            route_total_duration = iter['duration']
                        except:
                            route_total_duration = notavailableint
                        route_total_distance = 0 # set to 0 on start of each new route, well take the sum of all legs of a route
                        try:
                            route_total_transittime = iter['transitTime']
                        except:
                            route_total_transittime = notavailableint
                        try:
                            route_total_waitingtime = iter['waitingTime']
                        except:
                            route_total_waitingtime = notavailableint
                        try:
                            route_total_walktime = iter['walkTime']
                        except:
                            route_total_walktime = notavailableint
                        try:
                            route_total_walkdistance = iter['walkDistance']
                        except:
                            route_total_walkdistance = notavailableint
                        try:
                            route_total_transfers = iter['transfers']
                        except:
                            route_total_transfers = notavailableint
                        #print('From lat: ' + str(route_total_duration))
                        
                        # loop through legs --> they will become the features of our layer
                        route_leg_totaldistcounter = 0 # set to 0 on start of each new route
                        for leg in iter['legs']: 
                            route_legid += 1
                            feature = QgsFeature()
                            
                            try:
                                route_leg_starttime = leg['startTime']
                                route_leg_starttime = datetime.fromtimestamp(int(route_leg_starttime)/1000)
                                route_leg_starttime = QDateTime.fromString(str(route_leg_starttime),'yyyy-MM-dd hh:mm:ss')
                            except:
                                route_leg_starttime = notavailableothers
                            try:
                                route_leg_departuredelay = leg['departureDelay']
                            except:
                                route_leg_departuredelay = notavailableint
                            try:
                                route_leg_endtime = leg['endTime']
                                route_leg_endtime = datetime.fromtimestamp(int(route_leg_endtime)/1000)
                                route_leg_endtime = QDateTime.fromString(str(route_leg_endtime),'yyyy-MM-dd hh:mm:ss')
                            except:
                                route_leg_endtime = notavailableothers
                            try:
                                route_leg_arrivaldelay = leg['arrivalDelay']
                            except:
                                route_leg_arrivaldelay = notavailableint
                            try:
                                route_leg_duration = leg['duration']
                            except:
                                route_leg_duration = notavailableint
                            try:
                                route_leg_distance = leg['distance']
                                route_total_distance += route_leg_distance # Field does not exist in response. Build sum of all legs
                            except:
                                route_leg_distance = notavailableint
                                route_total_distance += 0 # Field does not exist in response.....
                            try:
                                route_leg_mode = leg['mode']
                            except:
                                route_leg_mode = notavailablestring
                            try:
                                route_leg_from_lat = leg['from']['lat']
                                route_leg_from_lon = leg['from']['lon']
                            except:
                                route_leg_from_lat = notavailableint
                                route_leg_from_lon = notavailableint
                            try:
                                route_leg_from_stopid = leg['from']['stopId']
                            except:
                                route_leg_from_stopid = notavailablestring
                            try:
                                route_leg_from_stopcode = leg['from']['stopCode']
                            except:
                                route_leg_from_stopcode = notavailablestring
                            try:
                                route_leg_from_name = leg['from']['name']
                            except:
                                route_leg_from_name = notavailablestring
                            try:
                                route_leg_from_departure = leg['from']['departure']
                                route_leg_from_departure = datetime.fromtimestamp(int(route_leg_from_departure)/1000)
                                route_leg_from_departure = QDateTime.fromString(str(route_leg_from_departure),'yyyy-MM-dd hh:mm:ss')
                            except:
                                route_leg_from_departure = notavailableothers
                            try:
                                route_leg_to_lat = leg['to']['lat']
                                route_leg_to_lon = leg['to']['lon']
                            except:
                                route_leg_to_lat = notavailableint
                                route_leg_to_lon = notavailableint
                            try:
                                route_leg_to_stopid = leg['to']['stopId']
                            except:
                                route_leg_to_stopid = notavailablestring
                            try:
                                route_leg_to_stopcode = leg['to']['stopCode']
                            except:
                                route_leg_to_stopcode = notavailablestring
                            try:
                                route_leg_to_name = leg['to']['name']
                            except:
                                route_leg_to_name = notavailablestring
                            try:
                                route_leg_to_arrival = leg['to']['arrival']
                                route_leg_to_arrival = datetime.fromtimestamp(int(route_leg_to_arrival)/1000)
                                route_leg_to_arrival = QDateTime.fromString(str(route_leg_to_arrival),'yyyy-MM-dd hh:mm:ss')
                            except:
                                route_leg_to_arrival = notavailableothers
                            
                            try:
                                route_leg_encodedpolylinestring = leg['legGeometry']['points']
                                route_leg_decodedpolylinestring_aspointlist = self.decode_polyline(route_leg_encodedpolylinestring)
                                feature.setGeometry(QgsGeometry.fromPolyline(route_leg_decodedpolylinestring_aspointlist))
                            except:
                                feature.setGeometry(QgsGeometry.fromPolyline(errorlinegeom))
                                route_error = 'Error decoding route geometry'
                            
                            # Create the feature
                            routes_memorylayer_pr.addFeature(feature)
                            # Adding the attributes to resultlayer
                            for key, value in fieldindexdict.items(): # keys contain the fieldindex, values the variablename which is the same as the fieldname, just in lowercase
                                fieldindex = key
                                #fieldvalue = getattr(self, value, 'default') # vars need to be named self.abc.. better use locals()
                                fieldvalue = locals()[value] # variables are named exactly as the fieldnames, just lowercase, we adjusted that before
                                attrs_leg = { fieldindex : fieldvalue }
                                routes_memorylayer_pr.changeAttributeValues({ feature.id() : attrs_leg }) # change attribute values of new layer to the just set ones  
                            fieldindex_source = 0 # fieldindex in sourcelayer
                            for key, value in fieldindexdict_source.items(): # loop through fields of sourcelayer
                                fieldindex_new = key # fieldindex in resultlayer
                                fieldvalue = self.routes_selectedlayer_source.getFeature(source_fid).attribute(fieldindex_source) # get value of sourcelayer
                                attrs_source = { fieldindex_new : fieldvalue } # prepare attributes
                                routes_memorylayer_pr.changeAttributeValues({ feature.id() : attrs_source }) # copy over value of sourcelayer to resultlayer
                                fieldindex_source += 1 # go to next field of sourcelayer
                            fieldindex_target = 0
                            for key, value in fieldindexdict_target.items():
                                fieldindex_new = key
                                fieldvalue = self.routes_selectedlayer_target.getFeature(target_fid).attribute(fieldindex_target)
                                attrs_target = { fieldindex_new : fieldvalue }
                                routes_memorylayer_pr.changeAttributeValues({ feature.id() : attrs_target })
                                fieldindex_target += 1
                            route_leg_totaldistcounter += 1 # counting the number of legs of a route
                            # END OF LOOP legs
                        
                        # Update total distance here since it is the sum of all legs and not available in response jsons
                        attr_totaldistance = { fieldindex_position_of_routetotaldistance : route_total_distance } # only change totaldistance field, we get its position while building the dict
                        current_featureid_totaldistance = feature.id() # the current featureid of a route, needed to count later in loop
                        last_featureid_totaldistance = feature.id() # the last featureid of a route
                        first_featureid_totaldistance = last_featureid_totaldistance - route_leg_totaldistcounter + 1 # the first featureid of a route
                        for features_before in range(first_featureid_totaldistance,last_featureid_totaldistance): # loop through all legs of the current route
                            routes_memorylayer_pr.changeAttributeValues({ features_before : attr_totaldistance }) # add the leg-sum of all legs of a route as totaldistance
                            current_featureid_totaldistance += 1
                            
                        # END OF LOOP iterinaries
                    # END OF if route_error_bool == False
                else: # Create error-dummyfeature if no route has been returned
                    route_routeid += 1
                    route_legid += 1
                    feature = QgsFeature()
                    route_error = 'Error: No Route'
                    try:
                        route_errorid = route_data['error']['id']
                    except:
                        route_errorid = notavailableint
                    try:
                        route_errordescription = route_data['error']['msg']
                    except:
                        route_errordescription = notavailablestring
                    try:
                        route_errormessage = route_data['error']['message']
                    except:
                        route_errormessage = notavailablestring
                    try:
                        route_errornopath = route_data['error']['noPath']
                    except:
                        route_errornopath = notavailablestring
                    
                    # Create dummy-geometry
                    feature.setGeometry(QgsGeometry.fromPolyline(errorlinegeom))
                    
                    # Create the feature
                    routes_memorylayer_pr.addFeature(feature)
                    # Adding the attributes to resultlayer
                    for key, value in fieldindexdict.items(): # keys contain the fieldindex, values the variablename which is the same as the fieldname, just in lowercase
                        fieldindex = key
                        #fieldvalue = getattr(self, value, 'default') # vars need to be named self.abc.. better use locals()
                        try:
                            fieldvalue = locals()[value] # variables are named exactly as the fieldnames, just lowercase, we adjusted that before
                        except:
                            fieldvalue = None # In case there is no value for it yet (happens if the first request returns an error). Otherwise we will get a key error
                        if fieldindex <= fieldindex_position_of_last_alwaysneededfield: # Only fill the first fields on error
                            attrs_leg = { fieldindex : fieldvalue }
                        else: # Leave the others empty as there is no data available
                            attrs_leg = { fieldindex : None }
                        routes_memorylayer_pr.changeAttributeValues({ feature.id() : attrs_leg }) # change attribute values of new layer to the just set ones  
                    fieldindex_source = 0 # fieldindex in sourcelayer
                    for key, value in fieldindexdict_source.items(): # loop through fields of sourcelayer
                        fieldindex_new = key # fieldindex in resultlayer
                        fieldvalue = self.routes_selectedlayer_source.getFeature(source_fid).attribute(fieldindex_source) # get value of sourcelayer
                        attrs_source = { fieldindex_new : fieldvalue } # prepare attributes
                        routes_memorylayer_pr.changeAttributeValues({ feature.id() : attrs_source }) # copy over value of sourcelayer to resultlayer
                        fieldindex_source += 1 # go to next field of sourcelayer
                    fieldindex_target = 0
                    for key, value in fieldindexdict_target.items():
                        fieldindex_new = key
                        fieldvalue = self.routes_selectedlayer_target.getFeature(target_fid).attribute(fieldindex_target)
                        attrs_target = { fieldindex_new : fieldvalue }
                        routes_memorylayer_pr.changeAttributeValues({ feature.id() : attrs_target })
                        fieldindex_target += 1
                    # END OF errorroutecreation
                i += 1
                routes_memorylayer_vl.updateFields()
                routes_memorylayer_vl.updateExtents()
                routes_memorylayer_vl.commitChanges() # Commit changes                
                if route_error != 'Success: No Error':
                    QgsMessageLog.logMessage(str(route_error) + ' - ErrorID: ' + str(route_errorid) + ' - ErrorDSC: ' + str(route_errordescription),MESSAGE_CATEGORY,Qgis.Warning)
                QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info) # adding a space to separate from next relation
                QgsMessageLog.logMessage("-----",MESSAGE_CATEGORY,Qgis.Info) # adding a space to separate from next relation
                QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info) # adding a space to separate from next relation
                
                # Update Progressbar
                progressbar_percent = progressbar_counter / float(progressbar_featurecount) * 100
                self.dlg.Routes_ProgressBar.setValue(progressbar_percent)
                # END OF LOOP through list of current value in matching dictionary
            
        # Finalizing resultlayer
        routes_memorylayer_vl.updateFields()
        routes_memorylayer_vl.updateExtents()
        routes_memorylayer_vl.commitChanges() # Commit changes

        self.iface.messageBar().pushMessage("Done!", " Routes job finished", MESSAGE_CATEGORY, level=Qgis.Success, duration=3) 
        routes_endtime = datetime.now()
        routes_runtime = routes_endtime - routes_starttime
        QgsMessageLog.logMessage("##### Routes job done in " + str(routes_runtime) + " @ " + str(datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")) + " #####",MESSAGE_CATEGORY,Qgis.Info)
        QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info)
        QgsMessageLog.logMessage("-----",MESSAGE_CATEGORY,Qgis.Info)
        QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info)
        
    def isochrones_request_isochrones(self):        
        # clear and initialize vars and stuff
        isochrone_url = None
        isochrones_error = None
        r = None
        inputlayer_outfeat = None
        debug_info = None
        isochrone_uid_counter = 0
        isochrone_id_counter = 0
        
        QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info)
        QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info)
        QgsMessageLog.logMessage("##### Isochrones job starting @ " + str(datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")) + " #####",MESSAGE_CATEGORY,Qgis.Info)
        QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info)
        isochrones_starttime = datetime.now()
        
        # Setting up Override Button context
        ctx = QgsExpressionContext(QgsExpressionContextUtils.globalProjectLayerScopes(self.isochrones_selectedlayer)) #This context will be able to evaluate global, project, and layer variables
        
        # Preparing Features
        inputlayer_features = self.isochrones_selectedlayer.getFeatures()
        
        # Create the Output-Vectorlayer
        isochrones_memorylayer_vl = QgsVectorLayer("MultiPolygon?crs=epsg:4326", "Isochrones", "memory") # Create temporary polygon layer (output file)
        isochrones_memorylayer_pr = isochrones_memorylayer_vl.dataProvider() # No idea what pr stands for, just copied this name from all the examples on the web... probably provider??
        isochrones_memorylayer_vl.startEditing() # Enter editing mode
        isochrones_memorylayer_pr.addAttributes([
                                          QgsField("Isochrone_Time",QVariant.Int),
                                          QgsField("Isochrone_UID", QVariant.Int),
                                          QgsField("Isochrone_ID", QVariant.Int),
                                          QgsField("Isochrone_Error", QVariant.String),
                                          QgsField("Isochrone_URL", QVariant.String)
                                          ]) # Add Error and URL Field to outputlayer
        isochrones_memorylayer_pr.addAttributes(self.isochrones_selectedlayer.fields()) # Copy all fieldnames of inputlayer to outputlayer  
        inputlayer_numberoffields = self.isochrones_selectedlayer.fields().count() # count number of fields in inputlayer
        inputlayer_outfeat = QgsFeature() # set QgsFeature
        
        # Savelocation
        otp_plugin_location = os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__))) #Read path of this plugin
        tmp_save_location = os.path.join(otp_plugin_location, 'temp_files\\')  #Concat path of this plugin to save location of temporary shapefiles

        # General Settings
        serverurl = self.serverurl #'https://api.digitransit.fi/routing/v1/routers/hsl/' #self.dlg.GeneralSettings_ServerURL.toPlainText()        
 
        # Preparing Transformation to WGS 84
        sourcecrs = QgsCoordinateReferenceSystem(self.isochrones_selectedlayer.crs().authid()) # Read CRS of input layer
        destcrs = QgsCoordinateReferenceSystem("EPSG:4326") # and set destination CRS to WGS 84 (OTP can only understand EPSG:4326) 
        tr = QgsCoordinateTransform(sourcecrs, destcrs, QgsProject.instance()) # Setting up transformation
        
        # Preparing Progressbar
        progressbar_featurecount = self.isochrones_selectedlayer.featureCount()
        progressbar_percent = 1 # Use 1 on start to show users that something is running if the first one takes a while
        progressbar_counter = 0
        self.dlg.Isochrones_ProgressBar.setValue(progressbar_percent)
        
        QgsProject.instance().addMapLayer(isochrones_memorylayer_vl)# Show in project
        
        for inputlayer_feature in inputlayer_features:
        
            # Initial Variables
            isochrones_error = 'Success: No Error' # Empty the error var
            progressbar_counter = progressbar_counter + 1
                
            # retrieve every feature with its geometry and attributes
            QgsMessageLog.logMessage("Feature ID: " + str(inputlayer_feature.id()),MESSAGE_CATEGORY,Qgis.Info)
            
            # Override Button Feature
            ctx.setFeature(inputlayer_feature) #Setting context to current feature
            
            # Feature Geometry
            geom = inputlayer_feature.geometry() # fetch geometry of current feature
            geom.transform(tr) # Transform geometry to WGS 84 (We prepared this outside the loop)
            pointgeom = geom.asPoint() #Read Point geometry
            x = round(pointgeom.x(),8) #Read X-Value
            y = round(pointgeom.y(),8) #Read Y-Value
            QgsMessageLog.logMessage("PointX: " + str(x) + " | PointY: " + str(y),MESSAGE_CATEGORY,Qgis.Info)
            
            # Feature Attributes
            Inputlayer_Attributes = inputlayer_feature.attributes() # fetch attributes
            #print(str(Inputlayer_Attributes)) # attrs is a list. It contains all the attribute values of this feature
            
            # Copy Attributes to outputlayer
            inputlayer_outfeat.setAttributes(inputlayer_feature.attributes()) # set the attributes
            #print (Inputlayer_Attributes[0])
            
            #Check where to gather attributes from: GUI or Layer? 
            #WalkSpeed
            if self.dlg.Isochrones_WalkSpeed_Use.isChecked() == True: # Check if option shall be used                
                if self.dlg.Isochrones_WalkSpeed_Override.isActive() == True: # Check if override button shall be used
                    isochrones_walkspeed_value, irrelevantsuccessstorage = self.dlg.Isochrones_WalkSpeed_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    isochrones_walkspeed_value = self.dlg.Isochrones_WalkSpeed.value() # Receiving Value from GUI: QDoubleSpinBox
                if isochrones_walkspeed_value is not None: # Check if received value is NULL
                    isochrones_walkspeed_ms = float(isochrones_walkspeed_value) * 0.27777777777778 # Convert float and km/h to m/s
                    isochrones_walkspeed_urlstring = '&walkSpeed=' + str(round(isochrones_walkspeed_ms,6)) # Concatenate to URL string if option is used and value is not NULL
                else:
                    isochrones_walkspeed_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
            else:
                isochrones_walkspeed_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
 
            #BikeSpeed
            if self.dlg.Isochrones_BikeSpeed_Use.isChecked() == True: # Check if option shall be used                
                if self.dlg.Isochrones_BikeSpeed_Override.isActive() == True: # Check if override button shall be used
                    isochrones_bikespeed_value, irrelevantsuccessstorage = self.dlg.Isochrones_BikeSpeed_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    isochrones_bikespeed_value = self.dlg.Isochrones_BikeSpeed.value() # Receiving Value from GUI: QDoubleSpinBox
                if isochrones_bikespeed_value is not None: # Check if received value is NULL
                    isochrones_bikespeed_ms = float(isochrones_bikespeed_value) * 0.27777777777778 # Convert float and km/h to m/s
                    isochrones_bikespeed_urlstring = '&bikeSpeed=' + str(round(isochrones_bikespeed_ms,6)) # Concatenate to URL string if option is used and value is not NULL
                else:
                    isochrones_bikespeed_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
            else:
                isochrones_bikespeed_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)

            #Date
            if self.dlg.Isochrones_Date_Use.isChecked() == True: # Check if option shall be used                
                if self.dlg.Isochrones_Date_Override.isActive() == True: # Check if override button shall be used
                    isochrones_date_value, irrelevantsuccessstorage = self.dlg.Isochrones_Date_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    isochrones_date_value = self.dlg.Isochrones_Date.date().toString("yyyy-MM-dd") # Receiving Value from GUI: QDateEdit
                if isochrones_date_value is not None: # Check if received value is NULL
                    isochrones_date_urlstring = '&date=' + str(isochrones_date_value) # Concatenate to URL string if option is used and value is not NULL
                else:
                    isochrones_date_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
            else:
                isochrones_date_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                
            #Time
            if self.dlg.Isochrones_Time_Use.isChecked() == True: # Check if option shall be used                
                if self.dlg.Isochrones_Time_Override.isActive() == True: # Check if override button shall be used
                    isochrones_time_value, irrelevantsuccessstorage = self.dlg.Isochrones_Time_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    isochrones_time_value = self.dlg.Isochrones_Time.time().toString("HH:mm:ss") # Receiving Value from GUI: QTimeEdit
                if isochrones_time_value is not None: # Check if received value is NULL
                    isochrones_time_urlstring = '&time=' + str(isochrones_time_value) # Concatenate to URL string if option is used and value is not NULL
                else:
                    isochrones_time_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
            else:
                isochrones_time_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                
            #ArriveBy
            if self.dlg.Isochrones_ArriveBy_Use.isChecked() == True: # Check if option shall be used                
                if self.dlg.Isochrones_ArriveBy_Override.isActive() == True: # Check if override button shall be used
                    isochrones_arriveby_value, irrelevantsuccessstorage = self.dlg.Isochrones_ArriveBy_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    isochrones_arriveby_value = self.dlg.Isochrones_ArriveBy.isChecked() # Receiving Value from GUI: QCheckBox
                if isochrones_arriveby_value is not None: # Check if received value is NULL
                    isochrones_arriveby_urlstring = '&arriveBy=' + str(isochrones_arriveby_value) # Concatenate to URL string if option is used and value is not NULL
                else:
                    isochrones_arriveby_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
            else:
                isochrones_arriveby_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                
            #Wheelchair
            if self.dlg.Isochrones_Wheelchair_Use.isChecked() == True: # Check if option shall be used                
                if self.dlg.Isochrones_Wheelchair_Override.isActive() == True: # Check if override button shall be used
                    isochrones_wheelchair_value, irrelevantsuccessstorage = self.dlg.Isochrones_Wheelchair_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    isochrones_wheelchair_value = self.dlg.Isochrones_Wheelchair.isChecked() # Receiving Value from GUI: QCheckBox
                if isochrones_wheelchair_value is not None: # Check if received value is NULL
                    isochrones_wheelchair_urlstring = '&wheelchair=' + str(isochrones_wheelchair_value) # Concatenate to URL string if option is used and value is not NULL
                else:
                    isochrones_wheelchair_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
            else:
                isochrones_wheelchair_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                
            #WaitReluctance
            if self.dlg.Isochrones_WaitReluctance_Use.isChecked() == True: # Check if option shall be used                
                if self.dlg.Isochrones_WaitReluctance_Override.isActive() == True: # Check if override button shall be used
                    isochrones_waitreluctance_value, irrelevantsuccessstorage = self.dlg.Isochrones_WaitReluctance_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    isochrones_waitreluctance_value = self.dlg.Isochrones_WaitReluctance.value() # Receiving Value from GUI: QDoubleSpinBox
                if isochrones_waitreluctance_value is not None: # Check if received value is NULL
                    isochrones_waitreluctance_float = round(float(isochrones_waitreluctance_value),2)
                    isochrones_waitreluctance_urlstring = '&waitReluctance=' + str(isochrones_waitreluctance_float) # Concatenate to URL string if option is used and value is not NULL
                else:
                    isochrones_waitreluctance_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
            else:
                isochrones_waitreluctance_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
                
            #MaxTransfers
            if self.dlg.Isochrones_MaxTransfers_Use.isChecked() == True: # Check if option shall be used                
                if self.dlg.Isochrones_MaxTransfers_Override.isActive() == True: # Check if override button shall be used
                    isochrones_maxtransfers_value, irrelevantsuccessstorage = self.dlg.Isochrones_MaxTransfers_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    isochrones_maxtransfers_value = self.dlg.Isochrones_MaxTransfers.value() # Receiving Value from GUI: QSpinBox
                if isochrones_maxtransfers_value is not None: # Check if received value is NULL
                    isochrones_maxtransfers_urlstring = '&maxTransfers=' + str(isochrones_maxtransfers_value) # Concatenate to URL string if option is used and value is not NULL
                else:
                    isochrones_maxtransfers_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
            else:
                isochrones_maxtransfers_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
             
            #MaxWalkDistance
            if self.dlg.Isochrones_MaxWalkDistance_Use.isChecked() == True: # Check if option shall be used                
                if self.dlg.Isochrones_MaxWalkDistance_Override.isActive() == True: # Check if override button shall be used
                    isochrones_maxwalkdistance_value, irrelevantsuccessstorage = self.dlg.Isochrones_MaxWalkDistance_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    isochrones_maxwalkdistance_value = self.dlg.Isochrones_MaxWalkDistance.value() # Receiving Value from GUI: QSpinBox
                if isochrones_maxwalkdistance_value is not None: # Check if received value is NULL
                    isochrones_maxwalkdistance_urlstring = '&maxWalkDistance=' + str(isochrones_maxwalkdistance_value) # Concatenate to URL string if option is used and value is not NULL
                else:
                    isochrones_maxwalkdistance_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
            else:
                isochrones_maxwalkdistance_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
             
            #MaxOffroadDistance
            if self.dlg.Isochrones_MaxOffroadDistance_Use.isChecked() == True: # Check if option shall be used                
                if self.dlg.Isochrones_MaxOffroadDistance_Override.isActive() == True: # Check if override button shall be used
                    isochrones_maxoffroaddistance_value, irrelevantsuccessstorage = self.dlg.Isochrones_MaxOffroadDistance_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    isochrones_maxoffroaddistance_value = self.dlg.Isochrones_MaxOffroadDistance.value() # Receiving Value from GUI: QSpinBox
                if isochrones_maxoffroaddistance_value is not None: # Check if received value is NULL
                    isochrones_maxoffroaddistance_urlstring = '&offRoadDistanceMeters=' + str(isochrones_maxoffroaddistance_value) # Concatenate to URL string if option is used and value is not NULL
                else:
                    isochrones_maxoffroaddistance_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
            else:
                isochrones_maxoffroaddistance_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)
             
            #PrecisionMeters
            if self.dlg.Isochrones_PrecisionMeters_Use.isChecked() == True: # Check if option shall be used                
                if self.dlg.Isochrones_PrecisionMeters_Override.isActive() == True: # Check if override button shall be used
                    isochrones_precisionmeters_value, irrelevantsuccessstorage = self.dlg.Isochrones_PrecisionMeters_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
                else:
                    isochrones_precisionmeters_value = self.dlg.Isochrones_PrecisionMeters.value() # Receiving Value from GUI: QSpinBox
                if isochrones_precisionmeters_value is not None: # Check if received value is NULL
                    isochrones_precisionmeters_urlstring = '&precisionMeters=' + str(isochrones_precisionmeters_value) # Concatenate to URL string if option is used and value is not NULL
                else:
                    isochrones_precisionmeters_urlstring = '' # Leave URL string empty if value is NULL (Empty, not NULL!!)
            else:
                isochrones_precisionmeters_urlstring = '' # Leave URL string empty if option is not used (Empty, not NULL!!)                   

            #Isochrones Interval
            if self.dlg.Isochrones_Interval_Override.isActive() == True:
                isochrones_interval_value, irrelevantsuccessstorage = self.dlg.Isochrones_Interval_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
            else:
                isochrones_interval_value = self.dlg.Isochrones_Interval.toPlainText() #Receiving Value from GUI: QTextEdit
            if not isochrones_interval_value: # Check if it is NULL
                isochrones_interval_value = '300,600,900' # Make sure cutoffSec is not empty because it is a must have parameter   
            isochrones_interval_value = isochrones_interval_value.replace(" ", "")  # Remove whitespaces in case user entered them              
            interval_list = list(isochrones_interval_value.split(",")) # Split given Integers (as string) separated by comma into a list
            isochrones_interval_urlstring = "&cutoffSec=".join(interval_list) #Join the list to a string and add leading "&cutoffSec=" to each Integer. The first item of the list will get no leading "&cutoffSec=", we will add this later

            #Transportation Mode
            if self.dlg.Isochrones_TransportationMode_Override.isActive() == True:
                isochrones_transportationmode_value, irrelevantsuccessstorage = self.dlg.Isochrones_TransportationMode_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
            else:
                isochrones_transportationmode_value = self.dlg.Isochrones_TransportationMode.toPlainText() #Receiving Value from GUI: QTextEdit
            if not isochrones_transportationmode_value: # Check if it is NULL
                isochrones_transportationmode_value = 'WALK,TRANSIT' # Make sure Mode is not empty because it is a must have parameter
            isochrones_transportationmode_urlstring = "&mode=" + isochrones_transportationmode_value.upper() # Make sure Mode is given as uppercase to prevent possible server errors (not sure how otp handels this exactly)
            
            #Additional Parameters
            if self.dlg.Isochrones_AdditionalParameters_Override.isActive() == True:
                isochrones_additionalparameters_value, irrelevantsuccessstorage = self.dlg.Isochrones_AdditionalParameters_Override.toProperty().value(ctx) #Receiving Value from Layer or GUI: DataDefinedOverride (Reference: https://gis.stackexchange.com/a/350279/107424 and https://gis.stackexchange.com/a/350993/107424)
            else:
                isochrones_additionalparameters_value = self.dlg.Isochrones_AdditionalParameters.toPlainText() #Receiving Value from GUI: QTextEdit
            if isochrones_additionalparameters_value is not None: # If Additional Parameters are filled, use it
                isochrones_additionalparameters_urlstring = str(isochrones_additionalparameters_value) # Create the string
            else: # If Additional Parameters are not filled, do not use it
                isochrones_additionalparameters_urlstring = '' # Create the string (Empty, because it is not used, not NULL!!)
                
            #Example URL: http://localhost:8080/otp/routers/ttc/isochrone?fromPlace=43.637,-79.434&mode=WALK,TRANSIT&date=11-14-2017&time=8:00am&maxWalkDistance=500&cutoffSec=1800&cutoffSec=3600
            #https://api.digitransit.fi/routing/v1/routers/hsl/isochrone?fromPlace=60.169,24.938&mode=WALK,TRANSIT&date=11-14-2017&time=8:00am&maxWalkDistance=500&cutoffSec=1800&cutoffSec=3600
            #Concat URL and convert to string
            isochrone_url = (str(serverurl) + "isochrone?algorithm=accSampling" + # Add Isochrones request and algorithm to server url
                            "&fromPlace=" + str(y) + "," + str(x) + # concatenate x and y coordinates as string
                            isochrones_transportationmode_urlstring + #
                            isochrones_walkspeed_urlstring + #
                            isochrones_bikespeed_urlstring + #
                            isochrones_date_urlstring + #
                            isochrones_time_urlstring + #
                            isochrones_arriveby_urlstring + #
                            isochrones_wheelchair_urlstring + #
                            isochrones_waitreluctance_urlstring + #
                            isochrones_maxtransfers_urlstring + #
                            isochrones_maxwalkdistance_urlstring + #
                            isochrones_maxoffroaddistance_urlstring + #
                            isochrones_precisionmeters_urlstring + #
                            isochrones_additionalparameters_urlstring + # Additional Parameters entered as OTP-Readable string -> User responsibility
                            "&cutoffSec=" + str(isochrones_interval_urlstring) # Interval-Integers are taken as comma separated string, then split into list and then joined to string with leading "&cutoffSec=". The first interval therefore has no leading "&cutoffSec=" thats why we add it here
                            )
                          
            #create url
            #Working example: https://api.digitransit.fi/routing/v1/routers/hsl/isochrone?fromPlace=60.169,24.938&mode=WALK,TRANSIT&date=2019-11-01&time=08:00:00&maxWalkDistance=500&cutoffSec=1800&cutoffSec=3600
            isochrone_url = isochrone_url #'https://api.digitransit.fi/routing/v1/routers/hsl/index/graphql'
            QgsMessageLog.logMessage(str(isochrone_url),MESSAGE_CATEGORY,Qgis.Info)
            debug_info = "Feature ID: " + str(inputlayer_feature.id()) + ' of Layer: ' + str(self.isochrones_selectedlayer) + ' at: ' + str(y) + ',' + str(x) + ' with URL: ' + str(isochrone_url) + '\n'
            
            #use lokal shp for testing to avoid bombing the server with requests :)
            #request and download file
            try:
                # someone who knows how to use QGIS proxy settings, please insert here :)
                isochrone_headers = {"accept":"application/x-zip-compressed"}
                isochrone_request = urllib.request.Request(isochrone_url, headers=isochrone_headers)
                isochrone_response = urllib.request.urlopen(isochrone_request)
                #r = requests.get(isochrone_url, headers={"accept":"application/x-zip-compressed"}, proxies=urllib.request.getproxies()) # Sending request to server. Using shapefiles to avoid invalid geometries on high level of detail + geojson throwback seems to be limited to 4 decimals. # Using urllib instead of requests to avoid prerequesites installation fails
            #save file
                try:                
                    with open(tmp_save_location + 'isochrones.zip', 'wb') as f: # Write shapefile to temp location
                        f.write(isochrone_response.read())
                        #f.write(r.content) # write zip content
            #unzip file
                    try:
                        with zipfile.ZipFile(tmp_save_location + 'isochrones.zip', 'r') as zip_ref:
                            zip_ref.extractall(tmp_save_location) 
            #load file
                        try:
                            isochrone_responseLayer = QgsVectorLayer(tmp_save_location + "null.shp", "null", "ogr") # load just downloaded file as vector layer
                            isochrone_responseLayer.updateExtents()
                        except:
                            isochrones_error = 'Error: loading response failed'
                            QgsMessageLog.logMessage(isochrones_error,MESSAGE_CATEGORY,Qgis.Warning)
                    except:
                        isochrones_error = 'Error: response file not valid'
                        QgsMessageLog.logMessage(isochrones_error,MESSAGE_CATEGORY,Qgis.Warning)
                except:
                    isochrones_error = 'Error: writing response to harddrive failed'
                    QgsMessageLog.logMessage(isochrones_error,MESSAGE_CATEGORY,Qgis.Warning)
            except:
                isochrones_error = 'Error: request failed' 
                QgsMessageLog.logMessage(isochrones_error,MESSAGE_CATEGORY,Qgis.Warning)


                
            # Check Validity of Responselayer
            try:
                if (not isochrone_responseLayer.isValid()) or (isochrone_responseLayer.extent().yMaximum() == 0.0) or (isochrone_responseLayer.extent().xMaximum() == 0.0) or (isochrone_responseLayer.extent().yMinimum() == 0.0) or (isochrone_responseLayer.extent().xMinimum() == 0.0):
                    isochrones_error = 'Error: response layer is not valid'
                    QgsMessageLog.logMessage(isochrones_error,MESSAGE_CATEGORY,Qgis.Warning)
            except:
                isochrones_error = 'Error: response layer is not valid'
                QgsMessageLog.logMessage(isochrones_error,MESSAGE_CATEGORY,Qgis.Warning)
            
            # Create Dummylayer on Error to prevent errors in code or broken result layer
            if isochrones_error != 'Success: No Error':
                isochrone_responseLayer = QgsVectorLayer("MultiPolygon?crs=epsg:4326","Errorlayer","memory")
                isochrone_responseLayer_pr = isochrone_responseLayer.dataProvider()
                isochrone_responseLayer.startEditing()
                error_feature = QgsFeature()
                error_feature.setGeometry(QgsGeometry.fromWkt("Polygon ((-0.1 -0.1, -0.1 0.1, 0.1 0.1, 0.1 -0.1, -0.1 -0.1))"))
                isochrone_responseLayer_pr.addAttributes([QgsField("time",QVariant.Int)])
                for j in interval_list:
                    isochrone_responseLayer_pr.addFeatures([error_feature])
                isochrone_responseLayer.commitChanges()
                isochrone_responseLayer.updateExtents()
                isochrones_error = isochrones_error + ' - Dummyfeature created to prevent entire result from beeing broken'
                
            # Throw back final status on this one
            if (isochrones_error != 'Success: No Error'):
                QgsMessageLog.logMessage('Final Status: ' + str(isochrones_error) + ' -> maybe try other settings like lower detail, other mode, ... or other coordinates, or ...',MESSAGE_CATEGORY,Qgis.Warning)
            
            #get features of file
            isochrone_features = isochrone_responseLayer.getFeatures() # get features of just downloaded isochrone 
            
            #iterate trough isochrone
            isochrone_id_counter = isochrone_id_counter + 1
            for isochrone_feature in isochrone_features:
                isochrone_uid_counter = isochrone_uid_counter + 1
                isochrones_memorylayer_pr.addFeature(isochrone_feature) # copy features of responselayer including geometry and attributes (it is always only one attribute) to new layer  
                attrs_isochrone = { 1 : isochrone_uid_counter, 2 : isochrone_id_counter, 3 : isochrones_error , 4 : isochrone_url } # set further generic attributes    
                isochrones_memorylayer_pr.changeAttributeValues({ isochrone_feature.id() : attrs_isochrone }) # change attribute values of new layer to the just set ones  
                for i in range(0, inputlayer_numberoffields): # iterate over new layer as many fields as the input layer has                
                    attrs_inputlayer = { i + 5 : Inputlayer_Attributes[i] } # set attributes of inputlayer (+5 because we added 5 new fields before)
                    isochrones_memorylayer_pr.changeAttributeValues({ isochrone_feature.id() : attrs_inputlayer }) # change attribute values of new layer to the ones from inputlayer 
                    if isochrones_error != 'Success: No Error': # change stuff to null/dummy if isochrone is not valid
                        err_attrs_isochrone = { 0 : 0 } # set time field to 0 on error
                        isochrones_memorylayer_pr.changeAttributeValues({ isochrone_feature.id() : err_attrs_isochrone }) # set time field to 0 on error
                        nullgeom = QgsGeometry.fromWkt("Polygon ((-0.1 -0.1, -0.1 0.1, 0.1 0.1, 0.1 -0.1, -0.1 -0.1))") # create pseudopolygon
                        #nullgeom = QgsGeometry.fromWkt('') #causes issues with layer. Just stick to pseudopolygon
                        isochrones_memorylayer_pr.changeGeometryValues({ isochrone_feature.id() : nullgeom }) # set geometry of feature to null on error 
                isochrones_memorylayer_vl.updateFields() # make sure to fetch changes from the provider
                isochrones_memorylayer_vl.updateExtents()
            
            isochrones_memorylayer_vl.updateFields()
            isochrones_memorylayer_vl.updateExtents()
            isochrones_memorylayer_vl.commitChanges() # Commit changes
            
            # Update Progressbar
            progressbar_percent = progressbar_counter / float(progressbar_featurecount) * 100
            self.dlg.Isochrones_ProgressBar.setValue(progressbar_percent)
            
            QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info)
            QgsMessageLog.logMessage("-----",MESSAGE_CATEGORY,Qgis.Info)
            QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info)
            
        #END OF LOOP
        
        # Isochrones Memory VectorLayer
        isochrones_memorylayer_vl.updateFields()
        isochrones_memorylayer_vl.updateExtents()
        isochrones_memorylayer_vl.commitChanges() # Commit changes

        self.iface.messageBar().pushMessage("Done!", " Isochrones job finished", MESSAGE_CATEGORY, level=Qgis.Success, duration=3)
        isochrones_endtime = datetime.now()
        isochrones_runtime = isochrones_endtime - isochrones_starttime
        QgsMessageLog.logMessage("##### Isochrones job done in " + str(isochrones_runtime) + " @ " + str(datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")) + " #####",MESSAGE_CATEGORY,Qgis.Info)
        QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info)
        QgsMessageLog.logMessage("-----",MESSAGE_CATEGORY,Qgis.Info)
        QgsMessageLog.logMessage("",MESSAGE_CATEGORY,Qgis.Info)
        
    def isochrones_maplayerselection(self): # Outsourcing layerselection to this function to avoid repeading the same code everywhere (Reference: https://gis.stackexchange.com/a/225659/107424)
        layers = QgsProject.instance().layerTreeRoot().children() # Fetch available layers
        self.dlg.Isochrones_SelectInputLayer.setFilters(QgsMapLayerProxyModel.PointLayer) # Filter out all layers except Point layers
        self.isochrones_selectedlayer = self.dlg.Isochrones_SelectInputLayer.currentLayer() # Using the currently selected layer in QgsMapLayerComboBox as selectedLayer
        if self.isochrones_selectedlayer is not None: # prevents showing python error when no point-layer is available
            self.isochrones_inputlayer_fieldnames = [field.name() for field in self.isochrones_selectedlayer.fields()] # Receive Isochrones_Inputlayer_Fieldnames from selected layer
        
        # Setting up QgsOverrideButtons (Reference: https://gis.stackexchange.com/a/350993/107424). Has to be done here, so they get updated when the layer selection has changed...
        #WalkSpeed
        self.dlg.Isochrones_WalkSpeed_Override.registerExpressionContextGenerator(self.isochrones_selectedlayer) # will allow the use of global, project, and layer variables.
        self.dlg.Isochrones_WalkSpeed_Override.init(0, QgsProperty(), QgsPropertyDefinition("walkSpeed", "Walk Speed in km/h", QgsPropertyDefinition.DoublePositive), self.isochrones_selectedlayer, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #BikeSpeed
        self.dlg.Isochrones_BikeSpeed_Override.registerExpressionContextGenerator(self.isochrones_selectedlayer) # will allow the use of global, project, and layer variables.
        self.dlg.Isochrones_BikeSpeed_Override.init(0, QgsProperty(), QgsPropertyDefinition("bikeSpeed", "Bike Speed in km/h", QgsPropertyDefinition.DoublePositive), self.isochrones_selectedlayer, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #Date
        self.dlg.Isochrones_Date_Override.registerExpressionContextGenerator(self.isochrones_selectedlayer) # will allow the use of global, project, and layer variables.
        self.dlg.Isochrones_Date_Override.init(0, QgsProperty(), QgsPropertyDefinition("Date", "Date in YYYY-MM-DD", QgsPropertyDefinition.String), self.isochrones_selectedlayer, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #Time
        self.dlg.Isochrones_Time_Override.registerExpressionContextGenerator(self.isochrones_selectedlayer) # will allow the use of global, project, and layer variables.
        self.dlg.Isochrones_Time_Override.init(0, QgsProperty(), QgsPropertyDefinition("Time", "Time in HH:MM:SS", QgsPropertyDefinition.String), self.isochrones_selectedlayer, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #ArriveBy
        self.dlg.Isochrones_ArriveBy_Override.registerExpressionContextGenerator(self.isochrones_selectedlayer) # will allow the use of global, project, and layer variables.
        self.dlg.Isochrones_ArriveBy_Override.init(0, QgsProperty(), QgsPropertyDefinition("ArriveBy", "ArriveBy as Boolean", QgsPropertyDefinition.Boolean), self.isochrones_selectedlayer, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #Wheelchair
        self.dlg.Isochrones_Wheelchair_Override.registerExpressionContextGenerator(self.isochrones_selectedlayer) # will allow the use of global, project, and layer variables.
        self.dlg.Isochrones_Wheelchair_Override.init(0, QgsProperty(), QgsPropertyDefinition("Wheelchair", "Wheelchair as Boolean", QgsPropertyDefinition.Boolean), self.isochrones_selectedlayer, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #WaitReluctance
        self.dlg.Isochrones_WaitReluctance_Override.registerExpressionContextGenerator(self.isochrones_selectedlayer) # will allow the use of global, project, and layer variables.
        self.dlg.Isochrones_WaitReluctance_Override.init(0, QgsProperty(), QgsPropertyDefinition("WaitReluctance", "Wait Reluctance Factor as Double", QgsPropertyDefinition.Double), self.isochrones_selectedlayer, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #MaxTransfers
        self.dlg.Isochrones_MaxTransfers_Override.registerExpressionContextGenerator(self.isochrones_selectedlayer) # will allow the use of global, project, and layer variables.
        self.dlg.Isochrones_MaxTransfers_Override.init(0, QgsProperty(), QgsPropertyDefinition("MaxTransfers", "Maximum Transfers as Integer", QgsPropertyDefinition.IntegerPositive), self.isochrones_selectedlayer, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #MaxWalkDistance
        self.dlg.Isochrones_MaxWalkDistance_Override.registerExpressionContextGenerator(self.isochrones_selectedlayer) # will allow the use of global, project, and layer variables.
        self.dlg.Isochrones_MaxWalkDistance_Override.init(0, QgsProperty(), QgsPropertyDefinition("MaxWalkDistance", "Maximum Walk Distance in Meters", QgsPropertyDefinition.IntegerPositive), self.isochrones_selectedlayer, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #MaxOffroadDistance
        self.dlg.Isochrones_MaxOffroadDistance_Override.registerExpressionContextGenerator(self.isochrones_selectedlayer) # will allow the use of global, project, and layer variables.
        self.dlg.Isochrones_MaxOffroadDistance_Override.init(0, QgsProperty(), QgsPropertyDefinition("MaxOffroadDistance", "Maximum Offroad Distance in Meters", QgsPropertyDefinition.IntegerPositive), self.isochrones_selectedlayer, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #PrecisionMeters
        self.dlg.Isochrones_PrecisionMeters_Override.registerExpressionContextGenerator(self.isochrones_selectedlayer) # will allow the use of global, project, and layer variables.
        self.dlg.Isochrones_PrecisionMeters_Override.init(0, QgsProperty(), QgsPropertyDefinition("PrecisionMeters", "Level of Detail in Meters", QgsPropertyDefinition.IntegerPositiveGreaterZero), self.isochrones_selectedlayer, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #Interval
        self.dlg.Isochrones_Interval_Override.registerExpressionContextGenerator(self.isochrones_selectedlayer) # will allow the use of global, project, and layer variables.
        self.dlg.Isochrones_Interval_Override.init(0, QgsProperty(), QgsPropertyDefinition("Interval", "Isochrones Interval in Seconds as String using Integer Values separated by Comma", QgsPropertyDefinition.String), self.isochrones_selectedlayer, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #TransportationMode
        self.dlg.Isochrones_TransportationMode_Override.registerExpressionContextGenerator(self.isochrones_selectedlayer) # will allow the use of global, project, and layer variables.
        self.dlg.Isochrones_TransportationMode_Override.init(0, QgsProperty(), QgsPropertyDefinition("TransportationMode", "TransportationMode as String separated by Comma", QgsPropertyDefinition.String), self.isochrones_selectedlayer, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #AdditionalParameters
        self.dlg.Isochrones_AdditionalParameters_Override.registerExpressionContextGenerator(self.isochrones_selectedlayer) # will allow the use of global, project, and layer variables.
        self.dlg.Isochrones_AdditionalParameters_Override.init(0, QgsProperty(), QgsPropertyDefinition("AdditionalParameters", "Additional Parameters as String", QgsPropertyDefinition.String), self.isochrones_selectedlayer, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition

        
    def routes_maplayerselection(self): # Outsourcing layerselection to this function to avoid repeading the same code everywhere (Reference: https://gis.stackexchange.com/a/225659/107424)
        layers = QgsProject.instance().layerTreeRoot().children() # Fetch available layers
        self.dlg.Routes_SelectInputLayer_Source.setFilters(QgsMapLayerProxyModel.PointLayer) # Filter out all layers except Point layers
        self.routes_selectedlayer_source = self.dlg.Routes_SelectInputLayer_Source.currentLayer() # Using the currently selected layer in QgsMapLayerComboBox as selectedLayer
        self.dlg.Routes_SelectInputLayer_Target.setFilters(QgsMapLayerProxyModel.PointLayer) # Filter out all layers except Point layers
        self.routes_selectedlayer_target = self.dlg.Routes_SelectInputLayer_Target.currentLayer() # Using the currently selected layer in QgsMapLayerComboBox as selectedLayer         
        if self.routes_selectedlayer_source is not None: # prevents showing python error when no point-layer is available
            self.routes_inputlayer_source_fieldnames = [field.name() for field in self.routes_selectedlayer_source.fields()] # Receive Inputlayer_Fieldnames from selected layer
        if self.routes_selectedlayer_target is not None: # prevents showing python error when no point-layer is available
            self.routes_inputlayer_target_fieldnames = [field.name() for field in self.routes_selectedlayer_target.fields()] # Receive Inputlayer_Fieldnames from selected layer
        self.routes_uidfield_source = self.dlg.Routes_SelectInputField_Source.setLayer(self.routes_selectedlayer_source) # Reference fieldselection to layer
        self.routes_uidfield_target = self.dlg.Routes_SelectInputField_Target.setLayer(self.routes_selectedlayer_target) # Reference fieldselection to layer
        try: # setup default selected fields
            if self.dlg.Routes_SelectInputField_Source.currentField() == '': # Only default if no field is selected
                if self.routes_selectedlayer_source.fields().indexFromName('id') == -1: # if no id field, use the first field
                    self.dlg.Routes_SelectInputField_Source.setCurrentIndex(0)
                else: # if id field, use it as default
                    self.dlg.Routes_SelectInputField_Source.setField('id')
                # same for targetlayer
            if self.dlg.Routes_SelectInputField_Target.currentField() == '': # Only default if no field is selected
                if self.routes_selectedlayer_target.fields().indexFromName('id') == -1:
                    self.dlg.Routes_SelectInputField_Target.setCurrentIndex(0)
                else:
                    self.dlg.Routes_SelectInputField_Target.setField('id')
        except: # if layer has no field, throw error
            self.iface.messageBar().pushMessage("Error", " Layer does not have any fields!", MESSAGE_CATEGORY, level=Qgis.Critical, duration=3)
            QgsMessageLog.logMessage("Layer does not have any fields!",MESSAGE_CATEGORY,Qgis.Warning)
            
        if self.dlg.Routes_DataDefinedLayer_Source.isChecked() == True:
            ddomaster = self.routes_selectedlayer_source
        elif self.dlg.Routes_DataDefinedLayer_Target.isChecked() == True:
            ddomaster = self.routes_selectedlayer_target
        else:
            ddomaster = self.routes_selectedlayer_source

        # Setting up QgsOverrideButtons (Reference: https://gis.stackexchange.com/a/350993/107424). Has to be done here, so they get updated when the layer selection has changed...
        # Use Sourcelayer as Master
        #WalkSpeed
        self.dlg.Routes_WalkSpeed_Override.registerExpressionContextGenerator(ddomaster) # will allow the use of global, project, and layer variables.
        self.dlg.Routes_WalkSpeed_Override.init(0, QgsProperty(), QgsPropertyDefinition("walkSpeed", "Walk Speed in km/h", QgsPropertyDefinition.DoublePositive), ddomaster, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #BikeSpeed
        self.dlg.Routes_BikeSpeed_Override.registerExpressionContextGenerator(ddomaster) # will allow the use of global, project, and layer variables.
        self.dlg.Routes_BikeSpeed_Override.init(0, QgsProperty(), QgsPropertyDefinition("bikeSpeed", "Bike Speed in km/h", QgsPropertyDefinition.DoublePositive), ddomaster, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #Date
        self.dlg.Routes_Date_Override.registerExpressionContextGenerator(ddomaster) # will allow the use of global, project, and layer variables.
        self.dlg.Routes_Date_Override.init(0, QgsProperty(), QgsPropertyDefinition("Date", "Date in YYYY-MM-DD", QgsPropertyDefinition.String), ddomaster, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #Time
        self.dlg.Routes_Time_Override.registerExpressionContextGenerator(ddomaster) # will allow the use of global, project, and layer variables.
        self.dlg.Routes_Time_Override.init(0, QgsProperty(), QgsPropertyDefinition("Time", "Time in HH:MM:SS", QgsPropertyDefinition.String), ddomaster, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #ArriveBy
        self.dlg.Routes_ArriveBy_Override.registerExpressionContextGenerator(ddomaster) # will allow the use of global, project, and layer variables.
        self.dlg.Routes_ArriveBy_Override.init(0, QgsProperty(), QgsPropertyDefinition("ArriveBy", "ArriveBy as Boolean", QgsPropertyDefinition.Boolean), ddomaster, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #Wheelchair
        self.dlg.Routes_Wheelchair_Override.registerExpressionContextGenerator(ddomaster) # will allow the use of global, project, and layer variables.
        self.dlg.Routes_Wheelchair_Override.init(0, QgsProperty(), QgsPropertyDefinition("Wheelchair", "Wheelchair as Boolean", QgsPropertyDefinition.Boolean), ddomaster, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #WaitReluctance
        self.dlg.Routes_WaitReluctance_Override.registerExpressionContextGenerator(ddomaster) # will allow the use of global, project, and layer variables.
        self.dlg.Routes_WaitReluctance_Override.init(0, QgsProperty(), QgsPropertyDefinition("WaitReluctance", "Wait Reluctance Factor as Double", QgsPropertyDefinition.Double), ddomaster, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #MaxTransfers
        self.dlg.Routes_MaxTransfers_Override.registerExpressionContextGenerator(ddomaster) # will allow the use of global, project, and layer variables.
        self.dlg.Routes_MaxTransfers_Override.init(0, QgsProperty(), QgsPropertyDefinition("MaxTransfers", "Maximum Transfers as Integer", QgsPropertyDefinition.IntegerPositive), ddomaster, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #MaxWalkDistance
        self.dlg.Routes_MaxWalkDistance_Override.registerExpressionContextGenerator(ddomaster) # will allow the use of global, project, and layer variables.
        self.dlg.Routes_MaxWalkDistance_Override.init(0, QgsProperty(), QgsPropertyDefinition("MaxWalkDistance", "Maximum Walk Distance in Meters", QgsPropertyDefinition.IntegerPositive), ddomaster, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #MaxOffroadDistance
        self.dlg.Routes_MaxOffroadDistance_Override.registerExpressionContextGenerator(ddomaster) # will allow the use of global, project, and layer variables.
        self.dlg.Routes_MaxOffroadDistance_Override.init(0, QgsProperty(), QgsPropertyDefinition("MaxOffroadDistance", "Maximum Offroad Distance in Meters", QgsPropertyDefinition.IntegerPositive), ddomaster, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #Iterinaries
        self.dlg.Routes_Iterinaries_Override.registerExpressionContextGenerator(ddomaster) # will allow the use of global, project, and layer variables.
        self.dlg.Routes_Iterinaries_Override.init(0, QgsProperty(), QgsPropertyDefinition("numIterinaries", "Number of Iterinaries", QgsPropertyDefinition.IntegerPositiveGreaterZero), ddomaster, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #Optimize
        self.dlg.Routes_Optimize_Override.registerExpressionContextGenerator(ddomaster) # will allow the use of global, project, and layer variables.
        self.dlg.Routes_Optimize_Override.init(0, QgsProperty(), QgsPropertyDefinition("Optimize", "Optimizationmode as String", QgsPropertyDefinition.String), ddomaster, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #TransportationMode
        self.dlg.Routes_TransportationMode_Override.registerExpressionContextGenerator(ddomaster) # will allow the use of global, project, and layer variables.
        self.dlg.Routes_TransportationMode_Override.init(0, QgsProperty(), QgsPropertyDefinition("TransportationMode", "TransportationMode as String separated by Comma", QgsPropertyDefinition.String), ddomaster, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        #AdditionalParameters
        self.dlg.Routes_AdditionalParameters_Override.registerExpressionContextGenerator(ddomaster) # will allow the use of global, project, and layer variables.
        self.dlg.Routes_AdditionalParameters_Override.init(0, QgsProperty(), QgsPropertyDefinition("AdditionalParameters", "Additional Parameters as String", QgsPropertyDefinition.String), ddomaster, False) # Need to tell the button which kind of property it expects. This is done by calling the init function of the button. This function expects a QgsPropertyDefinition
        
        
    def run(self):
        """Run method that performs all the real work"""
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = OpenTripPlannerPluginDialog()
            # Calling maplayer selection on first startup to load layers into QgsMapLayerComboBox and initialize QgsOverrideButton stuff so selections can be done without actually using the QgsMapLayerComboBox (related to currentIndexChanged.connect(self.isochrones_maplayerselection) below) 
            self.routes_maplayerselection()
            self.isochrones_maplayerselection() 
            # Execute Main-Functions on Click: Placing them here prevents them from beeing executed multiple times, see https://gis.stackexchange.com/a/137161/107424
            self.dlg.Isochrones_RequestIsochrones.clicked.connect(lambda: self.isochrones_request_isochrones()) #Call isochrones_request_isochrones function when clicking on RequestIsochrones button and handing over isochrones_selectedLayer. lambda function necessary to do this... (Reference: https://gis.stackexchange.com/a/351167/107424)
            self.dlg.Routes_RequestRoutes.clicked.connect(lambda: self.routes_request_routes())
        
        # Setting GUI stuff for startup
        self.dlg.Isochrones_Date.setDateTime(QtCore.QDateTime.currentDateTime()) # Set Dateselection to today on restart or firststart
        self.dlg.Routes_Date.setDateTime(QtCore.QDateTime.currentDateTime())
        self.dlg.Isochrones_ProgressBar.setValue(0) # Set Progressbar to 0 on restart or first start
        self.dlg.Routes_ProgressBar.setValue(0)
        self.dlg.GeneralSettings_ServerStatusResult.setText("Serverstatus Unknown")
        self.dlg.GeneralSettings_ServerStatusResult.setStyleSheet("background-color: white; color: black ")
            
        # Calling Functions to update layer stuff when layerselection has changed
        self.dlg.Isochrones_SelectInputLayer.currentIndexChanged.connect(self.isochrones_maplayerselection) # Call function isochrones_maplayerselection to update all selection related stuff when selection has been changed
        self.dlg.Routes_SelectInputLayer_Source.currentIndexChanged.connect(self.routes_maplayerselection)
        self.dlg.Routes_SelectInputLayer_Target.currentIndexChanged.connect(self.routes_maplayerselection)
        self.dlg.Routes_SelectInputField_Source.currentIndexChanged.connect(self.routes_maplayerselection) # or "fieldChanged"?
        self.dlg.Routes_SelectInputField_Target.currentIndexChanged.connect(self.routes_maplayerselection)
        self.dlg.Routes_DataDefinedLayer_Source.stateChanged.connect(self.routes_maplayerselection)
        self.dlg.Routes_DataDefinedLayer_Target.stateChanged.connect(self.routes_maplayerselection)
        
        # Calling Functions on button click
        self.dlg.GeneralSettings_CheckServerStatus.clicked.connect(self.check_server_status) #Open file dialog when hitting button
        self.dlg.GeneralSettings_Save.clicked.connect(self.store_general_variables) #Call store_general_variables function when clicking on save button
        self.dlg.Isochrones_SaveSettings.clicked.connect(self.store_isochrone_variables)
        self.dlg.Isochrones_RestoreDefaultSettings.clicked.connect(self.restore_isochrone_variables)
        self.dlg.Routes_SaveSettings.clicked.connect(self.store_route_variables)
        self.dlg.Routes_RestoreDefaultSettings.clicked.connect(self.restore_route_variables)
        
        # Functions to execute every time the plugin is opened
        self.read_general_variables() #Run Read-Stored-Variables-Function on every start
        self.read_isochrone_variables()
        self.read_route_variables()
        
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code. 
            QgsMessageLog.logMessage("OpenTripPlanner Plugin is already running! Close it before, if you wish to restart it.",MESSAGE_CATEGORY,Qgis.Warning)
            self.iface.messageBar().pushMessage("Error", "OpenTripPlanner Plugin is already running! Close it before, if you wish to restart it.",MESSAGE_CATEGORY,level=Qgis.Critical, duration=3)

#t1 = OpenTripPlannerPlugin(iface)
#QgsApplication.taskManager().addTask(t1)